<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Python - FangjieYu‘s site</title><meta name=Description content="This is my cool site"><meta property="og:url" content="https://fjyu95.github.io/posts/python-7e260258c8264083a9e6e0b25feca29c/">
<meta property="og:site_name" content="FangjieYu‘s site"><meta property="og:title" content="Python"><meta property="og:description" content="python笔记"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-23T00:00:00+00:00"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python"><meta name=twitter:description content="python笔记"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://fjyu95.github.io/posts/python-7e260258c8264083a9e6e0b25feca29c/><link rel=prev href=https://fjyu95.github.io/posts/git-bash/><link rel=next href=https://fjyu95.github.io/posts/online-toolkits-b6041ebb846649659d2145465714616c/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Python","inLanguage":"en-us","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/fjyu95.github.io\/posts\/python-7e260258c8264083a9e6e0b25feca29c\/"},"genre":"posts","keywords":"python","wordcount":18889,"url":"https:\/\/fjyu95.github.io\/posts\/python-7e260258c8264083a9e6e0b25feca29c\/","datePublished":"2022-10-25T00:00:00+00:00","dateModified":"2025-04-23T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"fjyu95"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="FangjieYu‘s site">fjyu95</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>posts </a><a class=menu-item href=/tags/>tags </a><a class=menu-item href=/categories/>category </a><a class=menu-item href=/about/>about </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="FangjieYu‘s site">fjyu95</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>posts</a><a class=menu-item href=/tags/ title>tags</a><a class=menu-item href=/categories/ title>category</a><a class=menu-item href=/about/ title>about</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Python</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://fjyu95.github.io/ title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>fjyu95</a></span>&nbsp;<span class=post-category>included in <a href=/categories/python/><i class="far fa-folder fa-fw" aria-hidden=true></i>Python</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-10-25>2022-10-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;18889 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;38 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#教程>教程</a></li><li><a href=#深浅复制>深浅复制</a><ul><li><ul><li><a href=#一句话核心区别>一句话核心区别：</a></li></ul></li></ul></li><li><a href=#f-string-格式化>f-string 格式化</a></li><li><a href=#进制转换>进制转换</a></li><li><a href=#任意键继续暂停>任意键继续/暂停</a></li><li><a href=#none值>None值</a></li><li><a href=#逻辑判断>逻辑判断</a></li><li><a href=#时间处理>时间处理</a><ul><li><a href=#计时器>计时器</a></li></ul></li><li><a href=#glob>glob</a></li><li><a href=#排序>排序</a></li><li><a href=#序列类型>序列类型</a></li><li><a href=#列表list>列表list</a><ul><li><a href=#转字符串>转字符串</a></li><li><a href=#-方法-1join--最常用方式适用于字符串列表>✅ 方法 1：<code>join()</code> — 最常用方式（适用于字符串列表）</a><ul><li><a href=#说明>🔹说明：</a></li></ul></li><li><a href=#-方法-2map--join--用于非字符串列表>✅ 方法 2：<code>map()</code> + <code>join()</code> — 用于<strong>非字符串列表</strong></a><ul><li><a href=#说明-1>🔹说明：</a></li></ul></li><li><a href=#-方法-3str-直接转带括号和逗号>✅ 方法 3：<code>str()</code> 直接转（带括号和逗号）</a><ul><li><a href=#说明-2>🔹说明：</a></li></ul></li><li><a href=#-方法-4list-comprehension-自定义格式化>✅ 方法 4：<code>list comprehension</code> 自定义格式化</a></li><li><a href=#-总结对比>🎯 总结对比：</a></li><li><a href=#列表生成式>列表生成式</a></li></ul></li><li><a href=#字典>字典</a></li><li><a href=#星号用法>星号*用法</a><ul><li><a href=#调用函数时使用->调用函数时使用* **</a></li></ul></li><li><a href=#print打印>print打印</a><ul><li><a href=#实时缓冲问题>实时缓冲问题</a><ul><li><a href=#方法一在脚本中设置-stdout-为无缓冲模式>方法一：在脚本中设置 <code>stdout</code> 为无缓冲模式</a></li><li><a href=#方法二使用-u-选项运行-python-脚本>方法二：使用 <code>u</code> 选项运行 Python 脚本</a></li><li><a href=#方法三在终端中设置环境变量>方法三：在终端中设置环境变量</a></li><li><a href=#代码解释>代码解释</a></li></ul></li></ul></li><li><a href=#argparse>argparse</a><ul><li><ul><li><a href=#常用参数选项><strong>常用参数选项</strong></a></li></ul></li><li><a href=#rawtexthelpformatter>RawTextHelpFormatter</a><ul><li><a href=#1-为什么使用>1. <strong>为什么使用 <code>RawTextHelpFormatter</code>？</strong></a></li></ul></li></ul></li><li><a href=#迭代器生成器>迭代器、生成器</a><ul><li><a href=#迭代器>迭代器</a></li><li><a href=#生成器>生成器</a><ul><li><a href=#生成器的基本特性>生成器的基本特性</a></li><li><a href=#创建生成器>创建生成器</a></li><li><a href=#1-使用生成器函数>1. 使用生成器函数</a></li></ul></li></ul></li><li><a href=#闭包>闭包</a><ul><li><ul><li><a href=#闭包的特点>闭包的特点</a></li><li><a href=#1-嵌套作用域>1. <strong>嵌套作用域</strong></a></li><li><a href=#2-函数对象>2. <strong>函数对象</strong></a></li><li><a href=#3-保持状态>3. <strong>保持状态</strong></a></li><li><a href=#4-避免全局变量>4. <strong>避免全局变量</strong></a></li><li><a href=#5-延迟计算>5. <strong>延迟计算</strong></a></li><li><a href=#创建闭包的步骤>创建闭包的步骤</a></li></ul></li></ul></li><li><a href=#装饰器>装饰器</a></li><li><a href=#随机数生成>随机数生成</a><ul><li><ul><li><a href=#区别总结>区别总结</a></li></ul></li><li><a href=#nprandom简单随机数><strong>np.random简单随机数</strong></a></li></ul></li><li><a href=#数据统计>数据统计</a></li><li><a href=#图像显示>图像显示</a></li><li><a href=#下划线>下划线</a></li><li><a href=#环境管理>环境管理</a><ul><li><a href=#切换工作目录>切换工作目录</a><ul><li><a href=#使用-os-模块>使用 <code>os</code> 模块</a></li><li><a href=#代码解释-1>代码解释</a></li><li><a href=#使用-pathlib-模块>使用 <code>pathlib</code> 模块</a></li><li><a href=#代码解释-2>代码解释</a></li></ul></li></ul></li><li><a href=#文件处理>文件处理</a></li><li><a href=#路径处理>路径处理</a></li><li><a href=#面向对象>面向对象</a></li><li><a href=#获取函数名>获取函数名</a><ul><li><ul><li><a href=#获取函数的名称><strong>获取函数的名称</strong></a></li></ul></li></ul></li><li><a href=#多进程>多进程</a></li><li><a href=#子进程>子进程</a><ul><li><a href=#方法对比>方法对比</a><ul><li><a href=#gpt>gpt</a></li><li><a href=#1><strong>1. <code>subprocess.run()</code>（推荐）</strong></a></li><li><a href=#示例><strong>示例</strong></a></li><li><a href=#优点><strong>优点</strong></a></li><li><a href=#2><strong>2. <code>subprocess.call()</code></strong></a></li><li><a href=#示例-1><strong>示例</strong></a></li><li><a href=#适用场景><strong>适用场景</strong></a></li><li><a href=#3><strong>3. <code>subprocess.Popen()</code>（适用于交互或流式处理）</strong></a></li><li><a href=#示例-2><strong>示例</strong></a></li><li><a href=#优点-1><strong>优点</strong></a></li><li><a href=#适用场景-1><strong>适用场景</strong></a></li><li><a href=#4><strong>4. <code>os.system()</code>（不推荐）</strong></a></li><li><a href=#示例-3><strong>示例</strong></a></li><li><a href=#缺点><strong>缺点</strong></a></li><li><a href=#5><strong>5. <code>commands.getoutput()</code>（仅 Python 2）</strong></a></li><li><a href=#示例python-2><strong>示例（Python 2）</strong></a></li><li><a href=#对比总结><strong>对比总结</strong></a></li><li><a href=#qwen>qwen</a></li><li><a href=#1-ossystem>1. <strong><code>os.system()</code></strong></a></li><li><a href=#特点>特点</a></li><li><a href=#示例-4>示例</a></li><li><a href=#适用场景-2>适用场景</a></li><li><a href=#2-subprocessrunpython-35-推荐>2. <strong><code>subprocess.run()</code></strong>（Python 3.5+ 推荐）</a></li><li><a href=#特点-1>特点</a></li><li><a href=#示例-5>示例</a></li><li><a href=#适用场景-3>适用场景</a></li><li><a href=#3-subprocesspopen高级控制>3. <strong><code>subprocess.Popen</code></strong>（高级控制）</a></li><li><a href=#特点-2>特点</a></li><li><a href=#示例-6>示例</a></li><li><a href=#适用场景-4>适用场景</a></li><li><a href=#4-subprocesscall>4. <strong><code>subprocess.call()</code> / <code>check_call()</code></strong></a></li><li><a href=#特点-3>特点</a></li><li><a href=#示例-7>示例</a></li><li><a href=#适用场景-5>适用场景</a></li><li><a href=#5-sh>5. <strong><code>sh</code> 模块（第三方库）</strong></a></li><li><a href=#特点-4>特点</a></li><li><a href=#示例-8>示例</a></li><li><a href=#适用场景-6>适用场景</a></li><li><a href=#对比总结表>对比总结表</a></li><li><a href=#安全最佳实践>安全最佳实践</a></li></ul></li><li><a href=#run详细用法>run详细用法</a></li><li><a href=#1-1><strong>1. <code>subprocess.run()</code> 语法</strong></a></li><li><a href=#2-详细参数说明><strong>2. 详细参数说明</strong></a></li><li><a href=#3-1><strong>3. <code>subprocess.run()</code> 示例</strong></a><ul><li><a href=#1最基本的使用><strong>（1）最基本的使用</strong></a></li><li><a href=#2捕获标准输出><strong>（2）捕获标准输出</strong></a></li><li><a href=#3使用><strong>（3）使用 <code>shell=True</code></strong></a></li><li><a href=#4改变工作目录><strong>（4）改变工作目录</strong></a></li><li><a href=#5传递输入><strong>（5）传递输入</strong></a></li><li><a href=#6超时控制><strong>（6）超时控制</strong></a></li><li><a href=#7错误处理><strong>（7）错误处理</strong></a></li></ul></li><li><a href=#4-1><strong>4. <code>subprocess.run()</code> 返回对象</strong></a></li><li><a href=#5-1><strong>5. <code>subprocess.run()</code> vs <code>subprocess.Popen()</code></strong></a></li><li><a href=#总结><strong>总结</strong></a></li><li><a href=#popen详细用法>Popen详细用法</a><ul><li><a href=#1-2><strong>1. <code>subprocess.Popen()</code> 基本格式</strong></a></li></ul></li><li><a href=#2-主要参数解析><strong>2. 主要参数解析</strong></a></li><li><a href=#3-2><strong>3. <code>args</code> 参数示例</strong></a><ul><li><a href=#-推荐shellfalse列表方式>✅ 推荐（<code>shell=False</code>，列表方式）</a></li><li><a href=#-shelltrue字符串方式>⚠️ <code>shell=True</code>（字符串方式）</a></li></ul></li><li><a href=#4-2><strong>4. <code>stdout</code> 和 <code>stderr</code> 捕获</strong></a></li><li><a href=#5-读取子进程的输出><strong>5. 读取子进程的输出</strong></a><ul><li><a href=#1-3><strong>(1) <code>process.communicate()</code> 方式</strong></a></li><li><a href=#2-1><strong>(2) <code>process.poll()</code> 轮询检查状态</strong></a></li><li><a href=#3-3><strong>(3) <code>process.wait()</code> 等待子进程结束</strong></a></li><li><a href=#4-逐行读取子进程输出><strong>(4) 逐行读取子进程输出</strong></a></li></ul></li><li><a href=#6><strong>6. <code>stdin</code> 传入数据</strong></a></li><li><a href=#7-终止子进程><strong>7. 终止子进程</strong></a></li><li><a href=#8-运行带环境变量的命令><strong>8. 运行带环境变量的命令</strong></a></li><li><a href=#9><strong>9. <code>cwd</code> 指定工作目录</strong></a></li><li><a href=#10-等待多个子进程><strong>10. 等待多个子进程</strong></a></li><li><a href=#总结-1><strong>总结</strong></a></li><li><a href=#pcommunicate-vs-ppoll>p.communicate() v.s. p.poll()</a></li><li><a href=#1-4><strong>1. <code>p.communicate()</code></strong></a><ul><li><a href=#示例-9><strong>示例</strong></a></li><li><a href=#特点-5><strong>特点</strong></a></li></ul></li><li><a href=#2-2><strong>2. <code>p.poll()</code></strong></a><ul><li><a href=#示例-10><strong>示例</strong></a></li><li><a href=#特点-6><strong>特点</strong></a></li></ul></li><li><a href=#3-何时用><strong>3. 何时用 <code>p.communicate()</code>，何时用 <code>p.poll()</code>？</strong></a></li><li><a href=#4-3><strong>4. <code>p.communicate()</code> vs <code>p.poll()</code> 综合示例</strong></a></li><li><a href=#总结-2><strong>总结</strong></a></li></ul></li><li><a href=#command-lines>command lines</a></li><li><a href=#open-source>open source</a></li><li><a href=#noqa>noqa</a><ul><li><ul><li><a href=#heading><strong>📌 <code># noqa</code> 作用</strong></a></li><li><a href=#1-忽略未使用的导入><strong>1️⃣ 忽略未使用的导入</strong></a></li><li><a href=#2-忽略长行超出-7988-字符限制><strong>2️⃣ 忽略长行超出 79/88 字符限制</strong></a></li><li><a href=#3-忽略><strong>3️⃣ 忽略 <code>E402</code>（导入不在文件顶部）</strong></a></li><li><a href=#heading-1><strong>💡 <code># noqa</code> 在深度学习中的常见场景</strong></a></li><li><a href=#-总结><strong>🚀 总结</strong></a></li></ul></li></ul></li><li><a href=#pythonpath>PYTHONPATH</a><ul><li><a href=#1-直接在-shell-中临时设置><strong>1. 直接在 Shell 中临时设置 <code>PYTHONPATH</code></strong></a></li><li><a href=#2-在-python-代码中手动添加><strong>2. 在 Python 代码中手动添加 <code>sys.path</code></strong></a></li><li><a href=#3-直接使用当前工作目录><strong>3. 直接使用当前工作目录</strong></a></li><li><a href=#4-在><strong>4. 在 <code>.bashrc</code> / <code>.bash_profile</code> / <code>.zshrc</code> 中永久设置 <code>PYTHONPATH</code></strong></a></li><li><a href=#5-确保><strong>5. 确保 <code>python</code> 解释器正确</strong></a></li><li><a href=#6-通过><strong>6. 通过 <code>sys.path</code> 检查 <code>PYTHONPATH</code></strong></a></li><li><a href=#总结-3><strong>总结</strong></a></li><li><a href=#pythonpath-vs-syspath>PYTHONPATH vs. sys.path</a></li><li><a href=#1-5><strong>1. <code>sys.path</code> 是 Python 解释器的模块搜索路径</strong></a></li><li><a href=#2-3><strong>2. <code>PYTHONPATH</code> 是环境变量，影响 <code>sys.path</code></strong></a></li><li><a href=#3-4><strong>3. <code>sys.path</code> 和 <code>PYTHONPATH</code> 的关系</strong></a></li><li><a href=#4-4><strong>4. <code>sys.path</code> 组成</strong></a></li><li><a href=#5-何时使用><strong>5. 何时使用 <code>PYTHONPATH</code> vs <code>sys.path</code>？</strong></a></li><li><a href=#6-选择使用><strong>6. 选择使用 <code>PYTHONPATH</code> 还是 <code>sys.path</code>？</strong></a></li><li><a href=#7-示例两种方式的使用><strong>7. 示例：两种方式的使用</strong></a><ul><li><a href=#方式-1使用><strong>方式 1：使用 <code>PYTHONPATH</code>（推荐长期设置）</strong></a></li><li><a href=#方式-2使用><strong>方式 2：使用 <code>sys.path.append()</code>（推荐短期/动态修改）</strong></a></li></ul></li><li><a href=#总结-4><strong>总结</strong></a><ul><li><a href=#-最佳实践>🚀 <strong>最佳实践</strong></a></li></ul></li><li><a href=#append-vs-insert0>append v.s. insert(0)</a><ul><li><a href=#1-核心区别>1. <strong>核心区别</strong></a></li><li><a href=#2-优先级对模块导入的影响>2. <strong>优先级对模块导入的影响</strong></a></li><li><a href=#场景-1使用-append>场景 1：使用 <code>append</code></a></li><li><a href=#场景-2使用-insert0->场景 2：使用 <code>insert(0, ...)</code></a></li><li><a href=#3-实际示例>3. <strong>实际示例</strong></a></li><li><a href=#31-使用-append>3.1 使用 <code>append</code></a></li><li><a href=#32-使用-insert>3.2 使用 <code>insert</code></a></li><li><a href=#4-选择标准>4. <strong>选择标准</strong></a></li><li><a href=#5-注意事项>5. <strong>注意事项</strong></a></li><li><a href=#6-替代方案>6. <strong>替代方案</strong></a></li><li><a href=#总结-5>总结</a></li></ul></li></ul></li><li><a href=#shebang语法>shebang语法</a><ul><li><a href=#-什么是-shebang>🔍 <strong>什么是 shebang？</strong></a></li><li><a href=#-shebang-在子进程中的使用场景>🧑‍💻 <strong>shebang 在子进程中的使用场景</strong></a><ul><li><a href=#1-子进程执行-python-脚本>1. <strong>子进程执行 Python 脚本</strong></a></li><li><a href=#为什么需要-shebang><strong>为什么需要 shebang？</strong></a></li><li><a href=#2-python-子进程调用外部程序>2. <strong>Python 子进程调用外部程序</strong></a></li></ul></li><li><a href=#-注意事项>⚠️ <strong>注意事项</strong></a></li><li><a href=#-是否推荐使用-shebang>✅ <strong>是否推荐使用 shebang？</strong></a><ul><li><a href=#-总结-1>👌 <strong>总结</strong></a></li></ul></li></ul></li><li><a href=#包引用>包引用</a><ul><li><a href=#deepseek>deepseek</a><ul><li><a href=#方法一动态添加根目录到syspath>方法一：动态添加根目录到sys.path</a></li><li><a href=#方法二设置pythonpath环境变量>方法二：设置PYTHONPATH环境变量</a></li><li><a href=#方法三使用可编辑安装推荐用于复杂项目>方法三：使用可编辑安装（推荐用于复杂项目）</a></li><li><a href=#目录结构示例>目录结构示例</a></li><li><a href=#总结-6>总结</a></li></ul></li><li><a href=#qwen-1>qwen</a><ul><li><a href=#方法一动态添加根目录到-syspath>方法一：动态添加根目录到 <code>sys.path</code></a></li><li><a href=#方法二自动查找根目录>方法二：自动查找根目录</a></li><li><a href=#方法三使用相对导入需包结构>方法三：使用相对导入（需包结构）</a></li><li><a href=#方法四设置环境变量>方法四：设置环境变量</a></li><li><a href=#方法五通过包安装推荐大型项目>方法五：通过包安装（推荐大型项目）</a></li><li><a href=#总结-7>总结</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><p><a href="https://www.notion.so/numpy-c46db07c0ef44f10b0a81765f94302ee?pvs=21" target=_blank rel="noopener noreffer">numpy</a></p><p><a href="https://www.notion.so/pandas-c07e7e22f45648ef964ed6a7a92d52e0?pvs=21" target=_blank rel="noopener noreffer">pandas</a></p><p><a href="https://www.notion.so/matplotlib-1502afd934ac4ab29334a80e6265fd0b?pvs=21" target=_blank rel="noopener noreffer">matplotlib</a></p><p><a href="https://www.notion.so/scikit-learn-2ebda846cabc43ed826a015e8e2ab7cf?pvs=21" target=_blank rel="noopener noreffer">scikit-learn</a></p><p><a href="https://www.notion.so/scipy-2d947a06cebc41e59c34654a1433ceae?pvs=21" target=_blank rel="noopener noreffer">scipy</a></p><h1 id=教程>教程</h1><p><a href=https://www.runoob.com/python3/python3-tutorial.html target=_blank rel="noopener noreffer">Python3 教程 | 菜鸟教程</a></p><p><a href=https://www.liaoxuefeng.com/wiki/1016959663602400 target=_blank rel="noopener noreffer">Python教程</a></p><h1 id=深浅复制>深浅复制</h1><ul><li>**直接赋值：**其实就是对象的引用（别名）。</li><li>**浅拷贝(copy)：**拷贝父对象，不会拷贝对象的内部的子对象。</li><li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li></ul><p><strong><code>形象理解:</code></strong></p><p><code>大箱子（容器）里面嵌套了许多小箱子，小箱子里面又有小箱子，最内部箱子里面有值</code></p><ul><li><strong>直接赋值：给最外部大箱子重新贴了一个tag</strong></li><li><strong>浅拷贝(copy)：重新换了一个外部大箱子</strong></li><li><strong>深拷贝(deepcopy)：全部箱子对应新换，值不变</strong></li></ul><h3 id=一句话核心区别>一句话核心区别：</h3><blockquote><p>引用就是用别名，浅拷贝是复制一层壳，深拷贝是复制全套内外。</p></blockquote><p><a href=https://www.runoob.com/python/att-dictionary-copy.html target=_blank rel="noopener noreffer">Python 字典(Dictionary) copy()方法</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/usr/bin/python
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1># -*- coding: UTF-8 -*-</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nv>dict1</span> <span class=o>=</span>  <span class=o>{</span><span class=s1>&#39;user&#39;</span>:<span class=s1>&#39;runoob&#39;</span>,<span class=s1>&#39;num&#39;</span>:<span class=o>[</span>1,2,3<span class=o>]}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nv>dict2</span> <span class=o>=</span> dict1          <span class=c1># 浅拷贝: 引用对象</span>
</span></span><span class=line><span class=cl><span class=nv>dict3</span> <span class=o>=</span> dict1.copy<span class=o>()</span>   <span class=c1># 浅拷贝：深拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 修改 data 数据</span>
</span></span><span class=line><span class=cl>dict1<span class=o>[</span><span class=s1>&#39;user&#39;</span><span class=o>]=</span><span class=s1>&#39;root&#39;</span>
</span></span><span class=line><span class=cl>dict1<span class=o>[</span><span class=s1>&#39;num&#39;</span><span class=o>]</span>.remove<span class=o>(</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 输出结果</span>
</span></span><span class=line><span class=cl>print<span class=o>(</span>dict1<span class=o>)</span>
</span></span><span class=line><span class=cl>print<span class=o>(</span>dict2<span class=o>)</span>
</span></span><span class=line><span class=cl>print<span class=o>(</span>dict3<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p><a href=https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html target=_blank rel="noopener noreffer">Python 直接赋值、浅拷贝和深度拷贝解析 | 菜鸟教程</a></p><p><a href=https://www.cnblogs.com/hokky/p/8476698.html target=_blank rel="noopener noreffer">Python-copy()与deepcopy()区别</a></p><h1 id=f-string-格式化>f-string 格式化</h1><p><a href=https://blog.csdn.net/sunxb10/article/details/81036693 target=_blank rel="noopener noreffer">Python格式化字符串f-string概览_sunxb10的博客-CSDN博客_f string</a></p><p>语法：</p><p><code>{content:format}</code></p><h1 id=进制转换>进制转换</h1><p><a href=https://blog.csdn.net/u012063703/article/details/42609833 target=_blank rel="noopener noreffer">Python 二进制，十进制，十六进制转换_kunpengku的博客-CSDN博客_python 二进制转十进制</a></p><p>转十进制：int(x,[base])</p><p>转二进制：bin()、</p><p>转8进制：oct()</p><p>转16进制：hex()</p><p><a href=https://www.runoob.com/python3/python3-conversion-binary-octal-hexadecimal.html target=_blank rel="noopener noreffer">Python 十进制转二进制、八进制、十六进制</a></p><p>内置函数：</p><p><a href=https://www.runoob.com/python3/python3-built-in-functions.html target=_blank rel="noopener noreffer">https://www.runoob.com/python3/python3-built-in-functions.html</a></p><p><a href=https://www.runoob.com/python3/python3-built-in-functions.html target=_blank rel="noopener noreffer">https://www.runoob.com/python3/python3-built-in-functions.html</a></p><h1 id=任意键继续暂停>任意键继续/暂停</h1><p><a href=https://www.jianshu.com/p/361e08618a97 target=_blank rel="noopener noreffer">python程序里，按任意键继续</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># windows</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>system</span><span class=p>(</span><span class=s1>&#39;pause&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># linux</span>
</span></span><span class=line><span class=cl><span class=nb>input</span><span class=p>(</span><span class=s1>&#39;Press any key to continue...&#39;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=none值>None值</h1><p><a href=https://www.jianshu.com/p/627232777efd target=_blank rel="noopener noreffer">python 中None，is和==的深入探讨</a></p><p>is表示的是对象标识符，用来检查对象的标识符是否一致，即两个对象在内存中的地址是否一致。在使用 <code>a is b</code> 的时候，相当于<code>id(a)==id(b)</code>。</p><p>因为None在Python里是个单例对象，一个变量如果是None，它一定和None指向同一个内存地址。</p><h1 id=逻辑判断>逻辑判断</h1><p><a href=https://zhuanlan.zhihu.com/p/78916154 target=_blank rel="noopener noreffer">[Python]万物皆可Bool——Python的隐式布尔值和真值测试</a></p><p>Python提供了一个简单有效的真值测试机制，来得到一切对象的隐式布尔值。该机制借助两个魔术方法<code>__bool__</code>和<code>__len__</code>，如果我们希望给自定义的类赋予符合一定逻辑的布尔值，可以通过定义这两个魔术方法来完成。Python也提供了一个内置函数<code>bool</code>，使得对象的隐式布尔值可以通过该函数显式计算得到，而不一定只能用于<code>if</code>，<code>while</code>等过程。</p><p><strong>任何对象</strong>都可以在<code>if</code>，<code>while</code>语句或<code>and</code>，<code>or</code>等布尔操作符中进行真值测试(Truth Value Testing)，测试的结果默认是<code>True</code>，除非一下两种情况的<strong>任何</strong>一种发生：</p><ul><li>该对象的类定义了<code>__bool__</code>函数，且该函数返回<code>False</code></li><li>该对象的类定义了<code>__len__</code>函数，且该函数返回<code>0</code></li></ul><p>另外，以下内置对象被认为是<code>False</code>:</p><ul><li>常量<code>None</code>和<code>False</code></li><li>值为0的数值类型：<code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Feaction(0, 1)</code></li><li>空的序列和容器类型：<code>''</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li></ul><p><a href=https://www.runoob.com/note/28793 target=_blank rel="noopener noreffer">Python true(真) 和 false(假)判断</a></p><table><thead><tr><th>类型</th><th>False</th><th>True</th></tr></thead><tbody><tr><td>布尔</td><td>False(与0等价)</td><td>True(与1等价)</td></tr><tr><td>数值</td><td>0,   0.0</td><td>非零的数值</td></tr><tr><td>字符串</td><td>&lsquo;&rsquo;,  &ldquo;"(空字符串)</td><td>非空字符串</td></tr><tr><td>容器</td><td>[],  (),  {},  set()</td><td>至少有一个元素的容器对象</td></tr><tr><td>None</td><td>None</td><td>非None对象</td></tr></tbody></table><h1 id=时间处理>时间处理</h1><p><a href=https://www.cnblogs.com/chenhuabin/p/10099766.html#_label1 target=_blank rel="noopener noreffer">Python时间日期格式化之time与datetime模块总结 - 奥辰 - 博客园</a></p><p><a href=https://blog.csdn.net/feng98ren/article/details/79530614 target=_blank rel="noopener noreffer">python记录程序运行时间的三种方法-CSDN博客</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=mi>1</span><span class=err>、</span><span class=nx>time</span><span class=p>.</span><span class=nx>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=mi>2</span><span class=err>、</span><span class=nx>datetime</span><span class=p>.</span><span class=nx>now</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=计时器>计时器</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>import functools
</span></span><span class=line><span class=cl>from datetime import datetime
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def timer<span class=o>(</span>func<span class=o>)</span>:
</span></span><span class=line><span class=cl>    <span class=c1># print(f&#39;{timer.__name__} is a func decorator.&#39;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    @functools.wraps<span class=o>(</span>func<span class=o>)</span>  <span class=c1># 保留func函数元信息</span>
</span></span><span class=line><span class=cl>    def warpper<span class=o>(</span>*args, **kwargs<span class=o>)</span>:
</span></span><span class=line><span class=cl>        <span class=nv>start</span> <span class=o>=</span> datetime.now<span class=o>()</span>
</span></span><span class=line><span class=cl>        print<span class=o>(</span>f<span class=s1>&#39;start {start}&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># print(func.__doc__) # 接口文档信息</span>
</span></span><span class=line><span class=cl>        <span class=nv>ret</span> <span class=o>=</span> func<span class=o>(</span>*args, **kwargs<span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=nv>end</span> <span class=o>=</span> datetime.now<span class=o>()</span>
</span></span><span class=line><span class=cl>        print<span class=o>(</span>f<span class=s1>&#39;end {end}&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        print<span class=o>(</span>f<span class=s1>&#39;run {func.__name__} cost {end - start}&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> ret
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> warpper
</span></span></code></pre></td></tr></table></div></div><h1 id=glob>glob</h1><p><a href=https://rgb-24bit.github.io/blog/2018/glob.html target=_blank rel="noopener noreffer">https://rgb-24bit.github.io/blog/2018/glob.html</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>glob</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pathname</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>src</span><span class=p>,</span> <span class=s1>&#39;*.txt&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>files</span> <span class=o>=</span> <span class=n>glob</span><span class=o>.</span><span class=n>glob</span><span class=p>(</span><span class=n>pathname</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=排序>排序</h1><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 相同前缀，只按数字部分进行排序</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>re</span>
</span></span><span class=line><span class=cl><span class=nb>sorted</span><span class=p>(</span><span class=n>dirs</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>int</span><span class=p>(</span><span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;\d+$&#39;</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span><span class=o>.</span><span class=n>group</span><span class=p>()))</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=序列类型>序列类型</h1><p><a href=https://zhuanlan.zhihu.com/p/147484306 target=_blank rel="noopener noreffer">python中不是所有的容器都叫序列</a></p><p>range to list</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>c</span> <span class=o>=</span> <span class=p>[</span><span class=o>*</span><span class=n>a</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=p>[</span><span class=o>*</span><span class=n>a</span><span class=p>,</span><span class=n>x</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=列表list>列表list</h1><h2 id=转字符串>转字符串</h2><p>在 Python 中将 <strong>列表转换为字符串</strong> 是常见操作，下面是各种方法的总结（适用于不同场景）👇</p><hr><h2 id=-方法-1join--最常用方式适用于字符串列表>✅ 方法 1：<code>join()</code> — 最常用方式（适用于字符串列表）</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;apple&#39;</span><span class=p>,</span> <span class=s1>&#39;banana&#39;</span><span class=p>,</span> <span class=s1>&#39;cherry&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=s1>&#39;, &#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>lst</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1># 输出: apple, banana, cherry</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=说明>🔹说明：</h3><ul><li><code>join()</code> 只能用于<strong>字符串组成的列表</strong>。</li><li>可自定义分隔符（如 <code>', '</code>, <code>'\n'</code>, <code>''</code> 等）。</li></ul><hr><h2 id=-方法-2map--join--用于非字符串列表>✅ 方法 2：<code>map()</code> + <code>join()</code> — 用于<strong>非字符串列表</strong></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=s1>&#39;,&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>str</span><span class=p>,</span> <span class=n>lst</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1># 输出: 1,2,3</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=说明-1>🔹说明：</h3><ul><li><code>map(str, lst)</code> 把列表中所有元素转成字符串。</li><li>比直接遍历更优雅、性能更好。</li></ul><hr><h2 id=-方法-3str-直接转带括号和逗号>✅ 方法 3：<code>str()</code> 直接转（带括号和逗号）</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;b&#39;</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>lst</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1># 输出: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=说明-2>🔹说明：</h3><ul><li>不推荐用于拼接字符串，仅用于查看或调试。</li><li>输出带有中括号 <code>[]</code> 和引号 <code>'a'</code>。</li></ul><hr><h2 id=-方法-4list-comprehension-自定义格式化>✅ 方法 4：<code>list comprehension</code> 自定义格式化</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=s1>&#39; | &#39;</span><span class=o>.</span><span class=n>join</span><span class=p>([</span><span class=sa>f</span><span class=s1>&#39;item:</span><span class=si>{</span><span class=n>x</span><span class=si>}</span><span class=s1>&#39;</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>lst</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1># 输出: item:1 | item:2 | item:3</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-总结对比>🎯 总结对比：</h2><table><thead><tr><th>方法</th><th>适用类型</th><th>输出格式</th><th>推荐程度</th></tr></thead><tbody><tr><td><code>', '.join(lst)</code></td><td>字符串列表</td><td>无括号</td><td>✅✅✅</td></tr><tr><td><code>', '.join(map(str, lst))</code></td><td>任意列表</td><td>无括号</td><td>✅✅✅</td></tr><tr><td><code>str(lst)</code></td><td>任意列表</td><td>有括号</td><td>⚠️ 一般</td></tr><tr><td>列表推导式 + join</td><td>任意列表</td><td>自定义格式</td><td>✅✅</td></tr></tbody></table><hr><h2 id=列表生成式>列表生成式</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>([</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> <span class=k>if</span> <span class=n>i</span><span class=o>%</span><span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>([</span><span class=n>i</span> <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=mi>100</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>)])</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p><a href=https://blog.csdn.net/ZK_J1994/article/details/72809260 target=_blank rel="noopener noreffer">Python列表解析配合if else_python 列表生成式 if else-CSDN博客</a></p><h1 id=字典>字典</h1><p>创建字典</p><p><a href=https://blog.csdn.net/qq_45261963/article/details/108936881 target=_blank rel="noopener noreffer">python创建字典(dict)的几种方法(详细版)_python如何构建字典-CSDN博客</a></p><p><a href=https://www.cnblogs.com/Little-Raccoon/p/10514551.html target=_blank rel="noopener noreffer">python字典的键值对互换 - Little_Raccoon - 博客园</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>d1</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;a&#39;</span><span class=p>:</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;b&#39;</span><span class=p>:</span><span class=mi>2</span><span class=p>,</span><span class=s1>&#39;c&#39;</span><span class=p>:</span><span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>d2</span> <span class=o>=</span> <span class=p>{</span><span class=n>key</span><span class=p>:</span><span class=n>value</span> <span class=k>for</span> <span class=n>v</span><span class=p>,</span><span class=n>k</span> <span class=ow>in</span> <span class=n>d1</span><span class=o>.</span><span class=n>items</span><span class=p>()}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=星号用法>星号*用法</h1><p><a href=https://www.jianshu.com/p/a159ea1dbccc target=_blank rel="noopener noreffer">https://www.jianshu.com/p/a159ea1dbccc</a></p><p>*位置参数</p><p>**关键字参数</p><h2 id=调用函数时使用->调用函数时使用* **</h2><p>test(<em>args)</em> 的作用其实就是把序列 args 中的每个元素，当作位置参数传进去。比如上面这个代码，如果 args 等于 (1,2,3) ，那么这个代码就等价于 test(1, 2, 3) 。</p><p>test(<strong>kwargs)</strong> 的作用则是把字典 kwargs 变成关键字参数传递。比如上面这个代码，如果 kwargs 等于 {&lsquo;a&rsquo;:1,&lsquo;b&rsquo;:2,&lsquo;c&rsquo;:3} ，那这个代码就等价于 test(a=1,b=2,c=3) 。</p><h1 id=print打印>print打印</h1><p>换行打印</p><p><code>print(*sys.path, sep='\n')</code></p><p><code>print('\n'.join(files))</code></p><h2 id=实时缓冲问题>实时缓冲问题</h2><p>这种现象通常是由于 Python 解释器的缓冲机制所导致的。在 PyCharm 里，它或许会对输出进行特殊处理，从而让日志能够实时显示；而在终端中，Python 解释器默认采用行缓冲或者块缓冲，这就使得日志要等到缓冲区满或者程序结束时才会被打印出来。下面为你介绍几种解决办法。</p><h3 id=方法一在脚本中设置-stdout-为无缓冲模式>方法一：在脚本中设置 <code>stdout</code> 为无缓冲模式</h3><p>你可以在 Python 脚本里把 <code>sys.stdout</code> 设置为无缓冲模式，这样就能让日志实时输出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 设置 stdout 为无缓冲模式</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>stdout</span><span class=o>.</span><span class=n>reconfigure</span><span class=p>(</span><span class=n>buffer</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>stdout</span><span class=o>.</span><span class=n>flush</span><span class=p>()</span> <span class=c1># or this</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>stdout</span><span class=o>.</span><span class=n>reconfigure</span><span class=p>(</span><span class=n>line_buffering</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>  <span class=c1># Python 3.7+</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;这是第 </span><span class=si>{</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=si>}</span><span class=s2> 条日志&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=c1># or this</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Logging info...&#34;</span><span class=p>,</span> <span class=n>flush</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=c1># 每句都要设置，不方便</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=方法二使用-u-选项运行-python-脚本>方法二：使用 <code>u</code> 选项运行 Python 脚本</h3><p>在调用 <code>subprocess.Popen()</code> 时，使用 <code>-u</code> 选项来运行 Python 脚本，这个选项的作用是强制使用无缓冲的标准输出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 -u 选项运行 Python 脚本</span>
</span></span><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s1>&#39;python&#39;</span><span class=p>,</span> <span class=s1>&#39;-u&#39;</span><span class=p>,</span> <span class=s1>&#39;your_script.py&#39;</span><span class=p>],</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>STDOUT</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 实时读取并打印日志</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>process</span><span class=o>.</span><span class=n>stdout</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>line</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 等待进程结束</span>
</span></span><span class=line><span class=cl><span class=n>process</span><span class=o>.</span><span class=n>wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># or this</span>
</span></span><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s1>&#39;python&#39;</span><span class=p>,</span> <span class=s1>&#39;my_script.py&#39;</span><span class=p>],</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>bufsize</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s1>&#39;unbuffer&#39;</span><span class=p>,</span> <span class=s1>&#39;python&#39;</span><span class=p>,</span> <span class=s1>&#39;my_script.py&#39;</span><span class=p>],</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s1>&#39;stdbuf&#39;</span><span class=p>,</span> <span class=s1>&#39;-oL&#39;</span><span class=p>,</span> <span class=s1>&#39;python&#39;</span><span class=p>,</span> <span class=s1>&#39;my_script.py&#39;</span><span class=p>],</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=方法三在终端中设置环境变量>方法三：在终端中设置环境变量</h3><p>在终端里设置 <code>PYTHONUNBUFFERED</code> 环境变量为 <code>1</code>，这样可以让 Python 解释器使用无缓冲的标准输出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PYTHONUNBUFFERED</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl>python your_script.py
</span></span></code></pre></td></tr></table></div></div><h3 id=代码解释>代码解释</h3><ul><li><strong>方法一</strong>：通过 <code>sys.stdout.reconfigure(buffer=0)</code> 把 <code>stdout</code> 设置为无缓冲模式，保证每次调用 <code>print()</code> 函数时日志都能立即输出。</li><li><strong>方法二</strong>：在 <code>subprocess.Popen()</code> 中使用 <code>u</code> 选项，让 Python 解释器以无缓冲模式运行脚本，然后实时读取并打印脚本的输出。</li><li><strong>方法三</strong>：设置 <code>PYTHONUNBUFFERED</code> 环境变量为 <code>1</code>，全局生效，使得所有 Python 脚本都以无缓冲模式运行。</li></ul><p>你可以根据具体情况选择合适的方法来解决日志不能实时输出的问题。</p><h1 id=argparse>argparse</h1><h3 id=常用参数选项><strong>常用参数选项</strong></h3><ul><li><code>type</code>：指定参数类型（如 <code>int</code>, <code>float</code>, <code>str</code> 等）。</li><li><code>default</code>：指定默认值。</li><li><code>help</code>：参数的帮助信息。</li><li><code>required</code>：是否必须提供（针对可选参数）。<code>required=True</code></li><li><code>choices</code>：限制参数的取值范围。<code>choices=['train', 'test']</code></li><li><code>nargs</code>：指定参数的数量（如 <code>?最多一个, *不限, +最少一个</code> 等）。</li><li><code>action</code>：指定参数的行为（如 <code>store_true</code>, <code>store_false，出现就选取默认值</code>）</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>argparse</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 1. 创建 ArgumentParser 对象</span>
</span></span><span class=line><span class=cl><span class=n>parser</span> <span class=o>=</span> <span class=n>argparse</span><span class=o>.</span><span class=n>ArgumentParser</span><span class=p>(</span><span class=n>description</span><span class=o>=</span><span class=s2>&#34;这是一个示例程序&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 添加参数</span>
</span></span><span class=line><span class=cl><span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;name&#39;</span><span class=p>,</span> <span class=nb>type</span><span class=o>=</span><span class=nb>str</span><span class=p>,</span> <span class=n>help</span><span class=o>=</span><span class=s2>&#34;你的名字&#34;</span><span class=p>)</span> <span class=c1># 位置参数</span>
</span></span><span class=line><span class=cl><span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;-a&#39;</span><span class=p>,</span> <span class=s1>&#39;--age&#39;</span><span class=p>,</span> <span class=nb>type</span><span class=o>=</span><span class=nb>int</span><span class=p>,</span> <span class=n>help</span><span class=o>=</span><span class=s2>&#34;你的年龄&#34;</span><span class=p>,</span> <span class=n>default</span><span class=o>=</span><span class=mi>18</span><span class=p>)</span> <span class=c1># 可选参数</span>
</span></span><span class=line><span class=cl><span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;-v&#39;</span><span class=p>,</span> <span class=s1>&#39;--verbose&#39;</span><span class=p>,</span> <span class=n>action</span><span class=o>=</span><span class=s1>&#39;store_true&#39;</span><span class=p>,</span> <span class=n>help</span><span class=o>=</span><span class=s2>&#34;是否显示详细信息&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 解析命令行参数</span>
</span></span><span class=line><span class=cl><span class=n>args</span> <span class=o>=</span> <span class=n>parser</span><span class=o>.</span><span class=n>parse_args</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4. 使用解析后的参数</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;你好, </span><span class=si>{</span><span class=n>args</span><span class=o>.</span><span class=n>name</span><span class=si>}</span><span class=s2>!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>args</span><span class=o>.</span><span class=n>verbose</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;年龄: </span><span class=si>{</span><span class=n>args</span><span class=o>.</span><span class=n>age</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=rawtexthelpformatter>RawTextHelpFormatter</h2><h3 id=1-为什么使用>1. <strong>为什么使用 <code>RawTextHelpFormatter</code>？</strong></h3><ul><li><strong>保留格式</strong>：默认的 <code>HelpFormatter</code> 会自动换行并调整文本格式，而 <code>RawTextHelpFormatter</code> 会保留帮助文本的原始格式。</li><li><strong>复杂帮助信息</strong>：当帮助信息包含多行文本、表格、代码块等复杂内容时，使用 <code>RawTextHelpFormatter</code> 可以更好地控制显示效果。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>argparse</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 RawTextHelpFormatter</span>
</span></span><span class=line><span class=cl><span class=n>parser</span> <span class=o>=</span> <span class=n>argparse</span><span class=o>.</span><span class=n>ArgumentParser</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>description</span><span class=o>=</span><span class=s1>&#39;这是一个示例程序</span><span class=se>\n\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;详细信息：</span><span class=se>\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;  - 第一行</span><span class=se>\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;  - 第二行</span><span class=se>\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;  - 第三行&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>formatter_class</span><span class=o>=</span><span class=n>argparse</span><span class=o>.</span><span class=n>RawTextHelpFormatter</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 添加参数</span>
</span></span><span class=line><span class=cl><span class=c1># 以为一个选项同时指定长选项和短选项</span>
</span></span><span class=line><span class=cl><span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;name&#39;</span><span class=p>,</span> <span class=n>help</span><span class=o>=</span><span class=s2>&#34;你的名字&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;-a&#39;</span><span class=p>,</span> <span class=s1>&#39;--age&#39;</span><span class=p>,</span> <span class=nb>type</span><span class=o>=</span><span class=nb>int</span><span class=p>,</span> <span class=n>help</span><span class=o>=</span><span class=s2>&#34;你的年龄</span><span class=se>\n</span><span class=s2>（默认值: 18）&#34;</span><span class=p>,</span> <span class=n>default</span><span class=o>=</span><span class=mi>18</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 解析参数</span>
</span></span><span class=line><span class=cl><span class=n>args</span> <span class=o>=</span> <span class=n>parser</span><span class=o>.</span><span class=n>parse_args</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用参数</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;你好, </span><span class=si>{</span><span class=n>args</span><span class=o>.</span><span class=n>name</span><span class=si>}</span><span class=s2>!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;年龄: </span><span class=si>{</span><span class=n>args</span><span class=o>.</span><span class=n>age</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=迭代器生成器>迭代器、生成器</h1><p>迭代器是一种按照从前向后的顺序依次访问元素的对象，访问时不能回退；<br>生成器是一个返回迭代器的函数，包含yield关键字，可以在迭代过程中逐步产生值，其遇到yield语句会暂停并return当前结果，函数会从上次暂停的地方继续执行。</p><h2 id=迭代器>迭代器</h2><p>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。</p><p>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p><h2 id=生成器>生成器</h2><p>生成器是 Python 中的一种特殊类型的迭代器，允许你使用 <code>yield</code> 关键字来逐步生成值，而不是一次性返回所有值。这使得生成器在处理大数据集时非常高效，因为它们可以按需生成数据，而不是在内存中存储所有数据。</p><h3 id=生成器的基本特性>生成器的基本特性</h3><ol><li><strong>延迟计算</strong>：生成器的值在需要时才计算，避免了一次性占用大量内存。</li><li><strong>可迭代性</strong>：生成器对象可以用在 <code>for</code> 循环中，也可以转换为列表、元组等可迭代对象。</li><li><strong>状态保持</strong>：每次调用生成器的 <code>__next__()</code> 方法时，生成器会记住上一次的状态（包括局部变量等）。</li></ol><h3 id=创建生成器>创建生成器</h3><p>生成器可以通过以下两种方式创建：</p><h3 id=1-使用生成器函数>1. 使用生成器函数</h3><p>生成器函数是一个普通函数，但使用 <code>yield</code> 语句返回值。例如：</p><pre tabindex=0><code>python
def count_up_to(n):
    count = 1
    while count &lt;= n:
        yield count
        count += 1

# 使用生成器
for number in count_up_to(5):
    print(number)

# print    
1
2
3
4
5
</code></pre><h1 id=闭包>闭包</h1><p>Python 中，闭包（Closure）是一个函数对象，能够“记住”其定义时的作用域，即使在函数的外部被调用时，仍然可以访问那些局部变量。闭包通常用于在函数内部定义另一个函数，并返回该内部函数。</p><h3 id=闭包的特点>闭包的特点</h3><h3 id=1-嵌套作用域>1. <strong>嵌套作用域</strong></h3><p>闭包的内部函数能够访问外部函数的变量。即使外部函数已经执行完毕，内部函数依然可以“记住”这些变量的状态。</p><h3 id=2-函数对象>2. <strong>函数对象</strong></h3><p>闭包是一个函数对象，它可以被调用并返回其值。这使得闭包可以被赋值给变量、作为参数传递或作为返回值返回。</p><h3 id=3-保持状态>3. <strong>保持状态</strong></h3><p>闭包可以用来维护状态。通过外部函数的参数，闭包能够记住外部函数的局部变量的值，适合于实现一些需要状态保持的功能。</p><h3 id=4-避免全局变量>4. <strong>避免全局变量</strong></h3><p>闭包可以在不使用全局变量的情况下，封装一些数据和状态。这增强了代码的封装性和可维护性。</p><h3 id=5-延迟计算>5. <strong>延迟计算</strong></h3><p>闭包可以用于延迟计算，因为它们可以在需要时才被调用。你可以创建一个闭包，在之后的时间点执行，而不是立即执行。</p><h3 id=创建闭包的步骤>创建闭包的步骤</h3><ol><li>定义一个外部函数。</li><li>在外部函数中定义一个内部函数。</li><li>在外部函数中返回内部函数。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>outer_function</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 定义外部函数，接收一个参数 x</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inner_function</span><span class=p>(</span><span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 定义内部函数，接收一个参数 y</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>  <span class=c1># 使用外部函数的参数 x</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>inner_function</span>  <span class=c1># 返回内部函数</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建闭包</span>
</span></span><span class=line><span class=cl><span class=n>closure</span> <span class=o>=</span> <span class=n>outer_function</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 调用闭包</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>closure</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>  <span class=c1># 这里 y = 5</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1># 输出 15，因为 10 + 5 = 15</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=装饰器>装饰器</h1><p><a href=https://www.runoob.com/w3cnote/python-func-decorators.html target=_blank rel="noopener noreffer">https://www.runoob.com/w3cnote/python-func-decorators.html</a></p><p><a href=https://foofish.net/python-decorator.html target=_blank rel="noopener noreffer">https://foofish.net/python-decorator.html</a></p><p><a href=https://blog.csdn.net/jpch89/article/details/84026130 target=_blank rel="noopener noreffer">https://blog.csdn.net/jpch89/article/details/84026130</a></p><h1 id=随机数生成>随机数生成</h1><p>在python中，有两个模块可以产生随机数：</p><ol><li>python自带random包： 提供一些基本的随机数产生函数，可满足基本需要</li></ol><p>2. <a href="https://so.csdn.net/so/search?q=numpy&amp;spm=1001.2101.3001.7020" target=_blank rel="noopener noreffer">numpy</a>.random：提供一些产生随机数的高级函数，满足高级需求</p><h3 id=区别总结>区别总结</h3><ol><li><strong>功能范围</strong>: <code>random</code> 模块提供的功能较为基础，而 <code>np.random</code> 提供的功能更强大，特别是在生成多维随机数方面更为高效和灵活。</li><li><strong>速度和效率</strong>: <code>np.random</code> 通常比 <code>random</code> 快，尤其是在生成大规模随机数时，因为 NumPy 是用 C 语言实现的，性能更高。</li><li><strong>多维数组</strong>: <code>np.random</code> 更适合科学计算，可直接生成多维数组的随机数，而 <code>random</code> 主要用于一维随机数生成。</li></ol><p>本文先分别介绍这两个包的常用函数，文末将总结一下两个包的区别。</p><p><a href=https://blog.csdn.net/qq_20011607/article/details/82288561 target=_blank rel="noopener noreffer">Python随机数小结——random和np.random的区别与联系_Zhang_Raymond的博客-CSDN博客</a></p><p><a href=https://www.jianshu.com/p/36a4bbb5536e target=_blank rel="noopener noreffer">【python】random与numpy.random</a></p><p><a href=https://www.cnblogs.com/oddcat/articles/9633771.html target=_blank rel="noopener noreffer">Python——随机数生成模块numpy.random - 怪猫佐良 - 博客园</a></p><p><code>np.random.seed(1234)</code></p><h2 id=nprandom简单随机数><strong>np.random简单随机数</strong></h2><table><thead><tr><th>函数名称</th><th>函数功能</th><th>参数说明</th></tr></thead><tbody><tr><td>rand(d0, d1, …, dn)</td><td>产生均匀分布的随机数</td><td>dn为第n维数据的维度</td></tr><tr><td>randn(d0, d1, …, dn)</td><td>产生标准正态分布随机数</td><td>dn为第n维数据的维度</td></tr><tr><td>randint(low[, high, size, dtype])</td><td>产生随机整数</td><td>low：最小值；high：最大值；size：数据个数</td></tr><tr><td>random_sample([size])</td><td>在[0,1）内产生随机数</td><td>size：随机数的shape，可以为元祖或者列表，[2,3]表示2维随机数，维度为（2,3）</td></tr><tr><td>random([size])</td><td>同random_sample([size])</td><td>同random_sample([size])</td></tr><tr><td>ranf([size])</td><td>同random_sample([size])</td><td>同random_sample([size])</td></tr><tr><td>sample([size]))</td><td>同random_sample([size])</td><td>同random_sample([size])</td></tr><tr><td>choice(a[, size, replace, p])</td><td>从a中随机选择指定数据</td><td>a：1维数组 size：返回数据形状</td></tr><tr><td>bytes(length)</td><td>返回随机位</td><td>length：位的长度</td></tr></tbody></table><h1 id=数据统计>数据统计</h1><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 平均值</span>
</span></span><span class=line><span class=cl>sum<span class=o>(</span>numbers<span class=o>)</span> / len<span class=o>(</span>numbers<span class=o>)</span>
</span></span><span class=line><span class=cl>math.mean<span class=o>(</span>numbers<span class=o>)</span> <span class=c1># Priority</span>
</span></span><span class=line><span class=cl>np.mean<span class=o>(</span>numbers<span class=o>)</span>
</span></span><span class=line><span class=cl>df.mean<span class=o>()</span> <span class=c1># pandas</span>
</span></span><span class=line><span class=cl>statistics.mean<span class=o>(</span>numeric_numbers<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=图像显示>图像显示</h1><p><a href=https://www.jb51.net/article/245048.htm target=_blank rel="noopener noreffer">解决plt.imshow显示cv2.imread读取的图像有色差发蓝的四种方法问题_python_脚本之家</a></p><p><a href=https://zhuanlan.zhihu.com/p/559488049 target=_blank rel="noopener noreffer">python bgr转rgb,Python OpenCV-imshow不需要从BGR转换为RGB</a></p><h1 id=下划线>下划线</h1><p><a href=https://www.runoob.com/w3cnote/python-5-underline.html target=_blank rel="noopener noreffer">Python 中下划线的 5 种含义 | 菜鸟教程</a></p><p><a href=https://blog.csdn.net/colourful_sky/article/details/81262449 target=_blank rel="noopener noreffer">python中的下划线&rdquo;_&ldquo;讲解_dfd中的下划线_随心1993的博客-CSDN博客</a></p><p>自定义的最好不要用双下划线</p><h1 id=环境管理>环境管理</h1><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 获取当前python环境</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>executable</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><a href="https://www.cnblogs.com/lovebkj/p/13848205.html#:~:text=%23%20%E5%9C%A8%E5%87%BD%E6%95%B0%E5%A4%96%E9%83%A8%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%8D%E7%A7%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8.__name__%E6%9D%A5%E8%8E%B7%E5%8F%96%E3%80%82%20def%20test_func_name1%20%28%29%3A%20print%20%28%27test%27%29%20func_name1,%28%29%3A%20print%20%28sys._getframe%20%28%29.f_code.co_name%29%20test_func_name2%20%28%29%20%23%20test_func_name2" target=_blank rel="noopener noreffer">Python获取当前运行函数的名称、类方法名称</a></p><p>在PyCharm中，你可以使用一些方法来判断当前是否处于Debug模式还是Run模式。以下是一些可能的方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 使用 sys 模块：</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nb>hasattr</span><span class=p>(</span><span class=n>sys</span><span class=p>,</span> <span class=s1>&#39;gettrace&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>sys</span><span class=o>.</span><span class=n>gettrace</span><span class=p>()</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Debug 模式&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Run 模式&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;无法确定模式&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>此方法通过检查</span> <span class=n>sys</span><span class=o>.</span><span class=n>gettrace</span><span class=p>()</span> <span class=n>是否为</span> <span class=kc>None</span> <span class=n>来判断是否处于调试模式</span><span class=err>。</span>
</span></span></code></pre></td></tr></table></div></div><p>使用 PyCharm 特定的环境变量：<br>PyCharm 在运行和调试时会设置一些环境变量，你可以利用这些环境变量来判断当前的模式。<br>例如，可以检查 PYCHARM_HOSTED 是否存在：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;PYCHARM_HOSTED&#39;</span><span class=p>)</span> <span class=o>==</span> <span class=s1>&#39;1&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Debug 模式&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Run 模式&#34;</span><span class=p>)</span><span class=err>`</span><span class=o>**</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>这种方法利用了PyCharm在Debug模式下设置的</span> <span class=n>PYCHARM_HOSTED</span> <span class=n>环境变量</span><span class=err>。</span>
</span></span></code></pre></td></tr></table></div></div><p>使用 <strong>debug</strong> 变量：<br>在 Python 中，存在一个特殊的 <strong>debug</strong> 变量，其在调试模式下为 True，在正常运行模式下为 False。在PyCharm的Debug模式下，<strong>debug</strong> 通常为 True。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=n>__debug__</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Debug 模式&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Run 模式&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这些方法中，第一和第二种方法是比较通用的，可以在其他IDE或环境中使用。第三种方法则是一种 Python 内建的方式，但需要注意的是，在某些特殊情况下可能会有异常。选择适合你项目和偏好的方法。</p><h2 id=切换工作目录>切换工作目录</h2><p>在 Python 脚本中，若要将脚本的当前工作目录（Current Working Directory，CWD）切换为脚本所在的目录，可借助 <code>os</code> 或 <code>pathlib</code> 模块来实现。下面为你分别介绍这两种模块的实现方式。</p><h3 id=使用-os-模块>使用 <code>os</code> 模块</h3><p><code>os</code> 模块提供了与操作系统进行交互的功能，可用于获取脚本的路径并切换工作目录。示例代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取脚本所在的目录</span>
</span></span><span class=line><span class=cl><span class=n>script_dir</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>abspath</span><span class=p>(</span><span class=vm>__file__</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 切换当前工作目录为脚本所在的目录</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>chdir</span><span class=p>(</span><span class=n>script_dir</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 打印当前工作目录进行验证</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;当前工作目录: </span><span class=si>{</span><span class=n>os</span><span class=o>.</span><span class=n>getcwd</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=代码解释-1>代码解释</h3><ol><li><strong>获取脚本所在的目录</strong>：<ul><li><code>os.path.abspath(__file__)</code>：<code>__file__</code> 是 Python 内置变量，代表当前脚本的文件名。<code>os.path.abspath()</code> 函数将其转换为绝对路径。</li><li><code>os.path.dirname()</code>：该函数用于获取文件所在的目录路径。</li></ul></li><li><strong>切换工作目录</strong>：<code>os.chdir()</code> 函数用于将当前工作目录切换到指定的目录。</li><li><strong>验证切换结果</strong>：<code>os.getcwd()</code> 函数用于获取当前工作目录，并将其打印输出。</li></ol><h3 id=使用-pathlib-模块>使用 <code>pathlib</code> 模块</h3><p><code>pathlib</code> 模块是 Python 3.4 及以上版本引入的面向对象的文件路径操作模块，使用起来更加简洁和直观。示例代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pathlib</span> <span class=kn>import</span> <span class=n>Path</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取脚本所在的目录</span>
</span></span><span class=line><span class=cl><span class=n>script_dir</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=vm>__file__</span><span class=p>)</span><span class=o>.</span><span class=n>resolve</span><span class=p>()</span><span class=o>.</span><span class=n>parent</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 切换当前工作目录为脚本所在的目录</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>chdir</span><span class=p>(</span><span class=n>script_dir</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 打印当前工作目录进行验证</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;当前工作目录: </span><span class=si>{</span><span class=n>os</span><span class=o>.</span><span class=n>getcwd</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=代码解释-2>代码解释</h3><ol><li><strong>获取脚本所在的目录</strong>：<ul><li><code>Path(__file__)</code>：创建一个 <code>Path</code> 对象，表示当前脚本的路径。</li><li><code>resolve()</code>：将相对路径转换为绝对路径。</li><li><code>parent</code>：获取该路径的父目录。</li></ul></li><li><strong>切换工作目录</strong>：同样使用 <code>os.chdir()</code> 函数将当前工作目录切换到指定的目录。</li><li><strong>验证切换结果</strong>：使用 <code>os.getcwd()</code> 函数获取并打印当前工作目录。</li></ol><p>通过以上两种方法，你可以将 Python 脚本的当前工作目录切换为脚本所在的目录。</p><h1 id=文件处理>文件处理</h1><p><a href=https://blog.csdn.net/weixin_40493501/article/details/106406110 target=_blank rel="noopener noreffer">Python字典保存（方便读取）_python 保存dict_风雨潇潇一书生的博客-CSDN博客</a></p><p><a href=https://www.delftstack.com/zh/howto/python/python-save-dictionary/ target=_blank rel="noopener noreffer">在 Python 中保存字典到文件</a></p><p><a href=https://blog.csdn.net/jacke121/article/details/81461192 target=_blank rel="noopener noreffer">Object of type &rsquo;ndarray&rsquo; is not JSON serializable_AI视觉网奇的博客-CSDN博客</a></p><p><code>shutil.copy2(src, dst) 复制文件，保留元数据</code></p><h1 id=路径处理>路径处理</h1><p><a href=http://c.biancheng.net/view/5693.html target=_blank rel="noopener noreffer">Python绝对路径和相对路径详解</a></p><p><a href=https://www.cnblogs.com/wuliytTaotao/p/9338259.html target=_blank rel="noopener noreffer">【python3基础】相对路径，‘/’，‘./’，‘../’ - wuliytTaotao - 博客园</a></p><p><a href=https://blog.csdn.net/F1004145107/article/details/106006655 target=_blank rel="noopener noreffer">Python - 获取当前目录/上级目录/上上级目录_python 如何访问上级目录_wise哲的博客-CSDN博客</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># -*- coding: UTF-8 -*-</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取当前目录</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>getcwd</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=vm>__file__</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>abspath</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=vm>__file__</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取上级目录</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>abspath</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=vm>__file__</span><span class=p>))))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>abspath</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>getcwd</span><span class=p>())))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>abspath</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>getcwd</span><span class=p>(),</span> <span class=s2>&#34;..&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取上上级目录</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>abspath</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>getcwd</span><span class=p>(),</span> <span class=s2>&#34;../..&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取上上上级目录</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>abspath</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>getcwd</span><span class=p>(),</span> <span class=s2>&#34;../../..&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ...以此类推</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=面向对象>面向对象</h1><p><a href=https://blog.csdn.net/jpch89/article/details/84026130 target=_blank rel="noopener noreffer">Python 中 property() 函数及 @property 装饰器的使用-CSDN博客</a></p><h1 id=获取函数名>获取函数名</h1><p><a href="https://www.cnblogs.com/lovebkj/p/13848205.html#:~:text=%23%20%E5%9C%A8%E5%87%BD%E6%95%B0%E5%A4%96%E9%83%A8%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%8D%E7%A7%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8.__name__%E6%9D%A5%E8%8E%B7%E5%8F%96%E3%80%82%20def%20test_func_name1%20%28%29%3A%20print%20%28%27test%27%29%20func_name1,%28%29%3A%20print%20%28sys._getframe%20%28%29.f_code.co_name%29%20test_func_name2%20%28%29%20%23%20test_func_name2" target=_blank rel="noopener noreffer">Python获取当前运行函数的名称、类方法名称</a></p><h3 id=获取函数的名称><strong>获取函数的名称</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 在函数外部获取函数的名称，可以使用.__name__来获取。</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>test_func_name1</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=s1>&#39;test&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func_name1</span> <span class=o>=</span> <span class=n>test_func_name1</span><span class=o>.</span><span class=vm>__name__</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>func_name1</span><span class=p>)</span>  <span class=c1># test_func_name1</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 在函数内部获取当前函数的名称，可以使用sys._getframe().f_code.co_name来获取</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>test_func_name2</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>_getframe</span><span class=p>()</span><span class=o>.</span><span class=n>f_code</span><span class=o>.</span><span class=n>co_name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>test_func_name2</span><span class=p>()</span>  <span class=c1># test_func_name2</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=多进程>多进程</h1><p>使用 multiprocessing 模块的 Pool 类的 apply 方法时，可以通过 get 方法获取子进程的返回值。以下是一个示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>multiprocessing</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>square</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>**</span><span class=n>name</span><span class=o>**</span> <span class=o>==</span> <span class=s2>&#34;**main**&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=c1># 创建一个进程池</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>multiprocessing</span><span class=o>.</span><span class=n>Pool</span><span class=p>()</span> <span class=k>as</span> <span class=n>pool</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=c1># 调用 square 函数，并传递参数</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>pool</span><span class=o>.</span><span class=n>apply</span><span class=p>(</span><span class=n>square</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=mi>5</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 输出结果</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;返回值:&#34;</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>在这个例子中，apply 方法会将 square 函数应用于参数 5，并返回结果。使用 get 方法获取返回值。</p><p>需要注意的是，apply 方法是阻塞的，即程序会等待子进程执行完毕并返回结果后才会继续执行。如果要并行执行多个任务并获取返回值，建议使用 map 方法。如果需要使用 apply，可以考虑使用 AsyncResult 对象来异步获取返回值。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>multiprocessing</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>square</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>**</span><span class=n>name</span><span class=o>**</span> <span class=o>==</span> <span class=s2>&#34;**main**&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=c1># 创建一个进程池</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>multiprocessing</span><span class=o>.</span><span class=n>Pool</span><span class=p>()</span> <span class=k>as</span> <span class=n>pool</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=c1># 调用 square 函数，并传递参数</span>
</span></span><span class=line><span class=cl><span class=n>result_async</span> <span class=o>=</span> <span class=n>pool</span><span class=o>.</span><span class=n>apply_async</span><span class=p>(</span><span class=n>square</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=mi>5</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 get 方法获取返回值</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>result_async</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 输出结果</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;返回值:&#34;</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这样可以实现异步获取返回值，而不会阻塞主进程。</p><p>apply_async 方法的执行顺序是不确定的，因为它取决于子进程的启动和执行速度。不同的子进程可能以不同的顺序完成执行。<br>因此，不能假设子进程的返回值的顺序与调用 apply_async 的顺序相同。</p><h1 id=子进程>子进程</h1><p>推荐</p><p>subprocess.run() # 阻塞处理</p><p>subprocess.Popen() # 非阻塞处理</p><h2 id=方法对比>方法对比</h2><h3 id=gpt>gpt</h3><p>在 Python 中，<code>subprocess</code> 模块是执行 shell 命令的主要方式。常用方法包括：</p><table><thead><tr><th>方法</th><th>适用场景</th><th>是否支持管道</th><th>是否获取返回值</th><th>是否阻塞</th></tr></thead><tbody><tr><td><code>subprocess.run()</code></td><td>简单命令，需等待执行完成</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td><code>subprocess.call()</code></td><td>简单命令，仅返回状态码</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td><code>subprocess.Popen()</code></td><td>需要实时交互或流式处理</td><td>✅</td><td>✅（<code>communicate()</code> 获取）</td><td>❌</td></tr><tr><td><code>os.system()</code></td><td>执行简单 shell 命令</td><td>❌</td><td>❌（仅返回状态码）</td><td>✅</td></tr><tr><td><code>commands.getoutput()</code>（Python 2）</td><td>仅 Python 2，可获取输出</td><td>❌</td><td>✅</td><td>✅</td></tr></tbody></table><hr><h3 id=1><strong>1. <code>subprocess.run()</code>（推荐）</strong></h3><p>Python 3.5+ 推荐使用 <code>subprocess.run()</code>，它可执行 shell 命令并返回 <code>CompletedProcess</code> 对象。</p><h3 id=示例><strong>示例</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span> <span class=n>capture_output</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>stdout</span><span class=p>)</span>  <span class=c1># 获取标准输出</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=优点><strong>优点</strong></h3><ul><li><strong>支持获取返回值</strong> (<code>stdout</code>, <code>stderr</code>)</li><li><strong>自动等待进程完成</strong></li><li><strong>支持 <code>capture_output=True</code> 直接获取输出</strong></li></ul><hr><h3 id=2><strong>2. <code>subprocess.call()</code></strong></h3><p>类似 <code>run()</code>，但<strong>只返回状态码</strong>，不返回输出。</p><h3 id=示例-1><strong>示例</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>return_code</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>call</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Exit Code:&#34;</span><span class=p>,</span> <span class=n>return_code</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=适用场景><strong>适用场景</strong></h3><ul><li>仅需要<strong>知道命令是否成功</strong>，而不关心输出。</li></ul><hr><h3 id=3><strong>3. <code>subprocess.Popen()</code>（适用于交互或流式处理）</strong></h3><p>适用于<strong>长时间运行的命令、实时读取输出</strong>或<strong>需要交互</strong>的情况。</p><h3 id=示例-2><strong>示例</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;ping&#34;</span><span class=p>,</span> <span class=s2>&#34;-c&#34;</span><span class=p>,</span> <span class=s2>&#34;4&#34;</span><span class=p>,</span> <span class=s2>&#34;google.com&#34;</span><span class=p>],</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>process</span><span class=o>.</span><span class=n>stdout</span><span class=p>:</span>  <span class=c1># 实时读取输出</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>line</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>process</span><span class=o>.</span><span class=n>wait</span><span class=p>()</span>  <span class=c1># 等待进程结束</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=优点-1><strong>优点</strong></h3><ul><li><strong>支持实时读取输出</strong></li><li><strong>不阻塞主线程</strong></li><li><strong>支持 <code>communicate()</code> 进行交互</strong></li></ul><h3 id=适用场景-1><strong>适用场景</strong></h3><ul><li><strong>长时间运行的进程</strong></li><li><strong>实时获取输出</strong></li><li><strong>需要进程间通信</strong></li></ul><hr><h3 id=4><strong>4. <code>os.system()</code>（不推荐）</strong></h3><p>执行 shell 命令，但<strong>无法获取输出</strong>，只返回退出状态码。</p><h3 id=示例-3><strong>示例</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>exit_code</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>system</span><span class=p>(</span><span class=s2>&#34;ls -l&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Exit Code:&#34;</span><span class=p>,</span> <span class=n>exit_code</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=缺点><strong>缺点</strong></h3><ul><li><strong>无法捕获输出</strong></li><li><strong>不支持管道</strong></li><li><strong>安全性较差（可能导致 Shell 注入）</strong></li></ul><hr><h3 id=5><strong>5. <code>commands.getoutput()</code>（仅 Python 2）</strong></h3><p>Python 3 已移除，等效于 <code>subprocess.check_output()</code>。</p><h3 id=示例python-2><strong>示例（Python 2）</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>commands</span>
</span></span><span class=line><span class=cl><span class=n>output</span> <span class=o>=</span> <span class=n>commands</span><span class=o>.</span><span class=n>getoutput</span><span class=p>(</span><span class=s2>&#34;ls -l&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>output</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h3 id=对比总结><strong>对比总结</strong></h3><table><thead><tr><th>方法</th><th>获取输出</th><th>获取状态码</th><th>是否推荐</th></tr></thead><tbody><tr><td><code>subprocess.run()</code></td><td>✅（可选 <code>capture_output=True</code>）</td><td>✅</td><td>✅ 推荐</td></tr><tr><td><code>subprocess.call()</code></td><td>❌</td><td>✅</td><td>❌ 仅适用于简单情况</td></tr><tr><td><code>subprocess.Popen()</code></td><td>✅（<code>stdout=PIPE</code>）</td><td>✅</td><td>✅ 适用于流式处理</td></tr><tr><td><code>os.system()</code></td><td>❌</td><td>✅</td><td>❌ 不推荐</td></tr><tr><td><code>commands.getoutput()</code>（Python 2）</td><td>✅</td><td>❌</td><td>❌ 仅适用于 Python 2</td></tr></tbody></table><p>🔹 <strong>推荐使用 <code>subprocess.run()</code>，如果需要流式处理则使用 <code>subprocess.Popen()</code></strong>。</p><h3 id=qwen>qwen</h3><p>以下是 Python 中执行 Shell 命令的子进程方法对比，包含使用场景、优缺点及代码示例：</p><hr><h3 id=1-ossystem>1. <strong><code>os.system()</code></strong></h3><h3 id=特点>特点</h3><ul><li><strong>简单直接</strong>：适合执行单条命令</li><li><strong>输出到终端</strong>：结果直接打印到控制台，无法捕获</li><li><strong>返回状态码</strong>：返回命令的退出状态码</li><li><strong>安全隐患</strong>：直接拼接字符串易受 Shell 注入攻击</li></ul><h3 id=示例-4>示例</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>exit_code</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>system</span><span class=p>(</span><span class=s2>&#34;ls -l&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;命令执行状态码: </span><span class=si>{</span><span class=n>exit_code</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=适用场景-2>适用场景</h3><ul><li>快速执行简单命令（如脚本启动）</li><li>无需捕获输出的场景</li></ul><hr><h3 id=2-subprocessrunpython-35-推荐>2. <strong><code>subprocess.run()</code></strong>（Python 3.5+ 推荐）</h3><h3 id=特点-1>特点</h3><ul><li><strong>功能全面</strong>：支持超时、输入/输出捕获、错误检查</li><li><strong>返回 <code>CompletedProcess</code> 对象</strong>：包含返回码、输出等信息</li><li><strong>默认阻塞</strong>：等待命令执行完成</li><li><strong>安全参数传递</strong>：通过列表形式避免 Shell 注入</li></ul><h3 id=示例-5>示例</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span>           <span class=c1># 命令参数列表</span>
</span></span><span class=line><span class=cl>    <span class=n>capture_output</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>    <span class=c1># 捕获 stdout/stderr</span>
</span></span><span class=line><span class=cl>    <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>              <span class=c1># 输出解码为字符串</span>
</span></span><span class=line><span class=cl>    <span class=n>timeout</span><span class=o>=</span><span class=mi>5</span>               <span class=c1># 超时时间（秒）</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;STDOUT:&#34;</span><span class=p>,</span> <span class=n>result</span><span class=o>.</span><span class=n>stdout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;STDERR:&#34;</span><span class=p>,</span> <span class=n>result</span><span class=o>.</span><span class=n>stderr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;返回码:&#34;</span><span class=p>,</span> <span class=n>result</span><span class=o>.</span><span class=n>returncode</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=适用场景-3>适用场景</h3><ul><li>需要捕获输出或检查错误的场景</li><li>需要超时控制的长时间任务</li></ul><hr><h3 id=3-subprocesspopen高级控制>3. <strong><code>subprocess.Popen</code></strong>（高级控制）</h3><h3 id=特点-2>特点</h3><ul><li><strong>非阻塞执行</strong>：可通过 <code>communicate()</code> 控制阻塞行为</li><li><strong>灵活的 I/O 管理</strong>：支持管道、重定向、实时读取输出</li><li><strong>复杂流程</strong>：适合需要多进程交互的场景（如管道）</li></ul><h3 id=示例-6>示例</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=s2>&#34;ping&#34;</span><span class=p>,</span> <span class=s2>&#34;google.com&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>text</span><span class=o>=</span><span class=kc>True</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 实时读取输出</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>stdout</span><span class=o>.</span><span class=n>readline</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>output</span> <span class=o>==</span> <span class=s1>&#39;&#39;</span> <span class=ow>and</span> <span class=n>process</span><span class=o>.</span><span class=n>poll</span><span class=p>()</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>output</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>output</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取最终结果</span>
</span></span><span class=line><span class=cl><span class=n>stdout</span><span class=p>,</span> <span class=n>stderr</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>communicate</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;最终输出:&#34;</span><span class=p>,</span> <span class=n>stdout</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=适用场景-4>适用场景</h3><ul><li>实时处理命令输出（如日志监控）</li><li>复杂进程交互（如管道、多命令组合）</li></ul><hr><h3 id=4-subprocesscall>4. <strong><code>subprocess.call()</code> / <code>check_call()</code></strong></h3><h3 id=特点-3>特点</h3><ul><li><strong>简单封装</strong>：<ul><li><code>call()</code>：返回状态码</li><li><code>check_call()</code>：状态码非零时抛出异常</li></ul></li><li><strong>阻塞执行</strong>：等待命令完成</li></ul><h3 id=示例-7>示例</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># call() 示例</span>
</span></span><span class=line><span class=cl><span class=n>exit_code</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>call</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;命令返回码: </span><span class=si>{</span><span class=n>exit_code</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># check_call() 示例</span>
</span></span><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>subprocess</span><span class=o>.</span><span class=n>check_call</span><span class=p>([</span><span class=s2>&#34;false&#34;</span><span class=p>])</span>  <span class=c1># 故意触发错误</span>
</span></span><span class=line><span class=cl><span class=k>except</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>CalledProcessError</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;命令失败，返回码: </span><span class=si>{</span><span class=n>e</span><span class=o>.</span><span class=n>returncode</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=适用场景-5>适用场景</h3><ul><li>需要简单判断命令是否成功的场景</li></ul><hr><h3 id=5-sh>5. <strong><code>sh</code> 模块（第三方库）</strong></h3><h3 id=特点-4>特点</h3><ul><li><strong>语法简洁</strong>：提供类似 Shell 的调用方式</li><li><strong>自动解码</strong>：输出直接返回字符串</li><li><strong>链式调用</strong>：支持管道操作</li></ul><h3 id=示例-8>示例</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sh</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 执行命令</span>
</span></span><span class=line><span class=cl><span class=n>output</span> <span class=o>=</span> <span class=n>sh</span><span class=o>.</span><span class=n>ls</span><span class=p>(</span><span class=s2>&#34;-l&#34;</span><span class=p>,</span> <span class=s2>&#34;/tmp&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 管道操作</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>sh</span><span class=o>.</span><span class=n>grep</span><span class=p>(</span><span class=n>sh</span><span class=o>.</span><span class=n>cat</span><span class=p>(</span><span class=s2>&#34;/etc/passwd&#34;</span><span class=p>),</span> <span class=s2>&#34;root&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=适用场景-6>适用场景</h3><ul><li>快速开发脚本（需安装 <code>sh</code> 库：<code>pip install sh</code>）</li></ul><hr><h3 id=对比总结表>对比总结表</h3><table><thead><tr><th>方法</th><th>输出捕获</th><th>实时处理</th><th>超时控制</th><th>安全性</th><th>复杂度</th><th>推荐场景</th></tr></thead><tbody><tr><td><code>os.system()</code></td><td>❌</td><td>❌</td><td>❌</td><td>低（易注入）</td><td>简单</td><td>快速执行简单命令</td></tr><tr><td><code>subprocess.run()</code></td><td>✅</td><td>❌</td><td>✅</td><td>高</td><td>中等</td><td>需要捕获输出的标准任务</td></tr><tr><td><code>subprocess.Popen</code></td><td>✅</td><td>✅</td><td>✅</td><td>高</td><td>复杂</td><td>实时交互或复杂进程管理</td></tr><tr><td><code>subprocess.call()</code></td><td>❌</td><td>❌</td><td>❌</td><td>中</td><td>简单</td><td>仅需状态码的简单命令</td></tr><tr><td><code>sh</code> 模块</td><td>✅</td><td>✅</td><td>❌</td><td>中</td><td>简单</td><td>快速脚本开发（第三方依赖）</td></tr></tbody></table><hr><h3 id=安全最佳实践>安全最佳实践</h3><ol><li><p><strong>避免 <code>shell=True</code></strong>：防止命令注入攻击</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 不安全写法</span>
</span></span><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=s2>&#34;ls &#34;</span> <span class=o>+</span> <span class=n>user_input</span><span class=p>,</span> <span class=n>shell</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 安全写法</span>
</span></span><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=n>user_input</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>参数列表化</strong>：始终将命令拆分为参数列表</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>shlex</span> <span class=kn>import</span> <span class=n>split</span>
</span></span><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;ping -c 4 google.com&#34;</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>限制权限</strong>：通过 <code>preexec_fn</code> 或用户组限制子进程权限（Unix）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=s2>&#34;dangerous_cmd&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>preexec_fn</span><span class=o>=</span><span class=k>lambda</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>setuid</span><span class=p>(</span><span class=mi>1000</span><span class=p>)</span>  <span class=c1># 降权运行</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><hr><p>根据需求选择合适的方法，推荐优先使用 <code>subprocess.run()</code> 或 <code>subprocess.Popen</code> 以获得更好的控制和安全性。</p><h2 id=run详细用法>run详细用法</h2><p><code>subprocess.run()</code> 是 Python <code>subprocess</code> 模块中的一个常用方法，用于执行 shell 命令，并等待命令完成后返回结果。</p><hr><h2 id=1-1><strong>1. <code>subprocess.run()</code> 语法</strong></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>args</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>stdin</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=nb>input</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>stdout</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>stderr</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>capture_output</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=n>shell</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>cwd</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>check</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>encoding</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=2-详细参数说明><strong>2. 详细参数说明</strong></h2><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td><strong><code>args</code></strong></td><td>需要执行的命令（字符串或列表）</td><td>必须提供</td></tr><tr><td><strong><code>stdin</code></strong></td><td>指定子进程的标准输入（如 <code>subprocess.PIPE</code>）</td><td><code>None</code></td></tr><tr><td><strong><code>input</code></strong></td><td>传递给子进程的输入数据（如字符串或字节流）</td><td><code>None</code></td></tr><tr><td><strong><code>stdout</code></strong></td><td>指定子进程的标准输出（如 <code>subprocess.PIPE</code> 捕获输出）</td><td><code>None</code></td></tr><tr><td><strong><code>stderr</code></strong></td><td>指定子进程的标准错误输出</td><td><code>None</code></td></tr><tr><td><strong><code>capture_output</code></strong></td><td>如果为 <code>True</code>，等价于 <code>stdout=subprocess.PIPE, stderr=subprocess.PIPE</code></td><td><code>False</code></td></tr><tr><td><strong><code>shell</code></strong></td><td>是否通过 shell 运行命令（如 <code>bash</code>）</td><td><code>False</code></td></tr><tr><td><strong><code>cwd</code></strong></td><td>指定运行命令的工作目录</td><td><code>None</code></td></tr><tr><td><strong><code>timeout</code></strong></td><td>超时时间（秒），超过时间会抛出 <code>subprocess.TimeoutExpired</code> 异常</td><td><code>None</code></td></tr><tr><td><strong><code>check</code></strong></td><td>是否检查返回码，如果非 0 则抛出 <code>subprocess.CalledProcessError</code></td><td><code>False</code></td></tr><tr><td><strong><code>encoding</code></strong></td><td>指定输出的编码（如 <code>encoding="utf-8"</code>）</td><td><code>None</code></td></tr><tr><td><strong><code>text</code></strong></td><td><code>True</code> 时等价于 <code>encoding="utf-8"</code>，返回字符串而非字节流</td><td><code>None</code></td></tr></tbody></table><hr><h2 id=3-1><strong>3. <code>subprocess.run()</code> 示例</strong></h2><h3 id=1最基本的使用><strong>（1）最基本的使用</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>])</span>  <span class=c1># 运行 ls -l</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=2捕获标准输出><strong>（2）捕获标准输出</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span> <span class=n>capture_output</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>stdout</span><span class=p>)</span>  <span class=c1># 获取命令输出</span>
</span></span></code></pre></td></tr></table></div></div><p>等价于：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>stdout</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=3使用><strong>（3）使用 <code>shell=True</code></strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=s2>&#34;echo Hello World&#34;</span><span class=p>,</span> <span class=n>shell</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>  <span class=c1># 通过 shell 运行</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>⚠️ 注意：</p><ul><li><code>shell=True</code> 适用于运行复杂的 shell 命令，如 <code>ls *.txt | grep "data"</code> 。</li><li><strong>不推荐</strong>对不受信任的输入使用 <code>shell=True</code>，因为可能导致 <strong>命令注入</strong>（安全风险）。</li></ul></blockquote><h3 id=4改变工作目录><strong>（4）改变工作目录</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span> <span class=n>cwd</span><span class=o>=</span><span class=s2>&#34;/home/user&#34;</span><span class=p>)</span>  <span class=c1># 在 /home/user 目录下执行 ls -l</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=5传递输入><strong>（5）传递输入</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;cat&#34;</span><span class=p>],</span> <span class=nb>input</span><span class=o>=</span><span class=s2>&#34;Hello, World!&#34;</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>capture_output</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>stdout</span><span class=p>)</span>  <span class=c1># 输出：Hello, World!</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=6超时控制><strong>（6）超时控制</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;sleep&#34;</span><span class=p>,</span> <span class=s2>&#34;10&#34;</span><span class=p>],</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>except</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>TimeoutExpired</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;进程超时！&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=7错误处理><strong>（7）错误处理</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;/nonexistent_path&#34;</span><span class=p>],</span> <span class=n>check</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>  <span class=c1># 目录不存在会报错</span>
</span></span><span class=line><span class=cl><span class=k>except</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>CalledProcessError</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;命令失败，返回码: </span><span class=si>{</span><span class=n>e</span><span class=o>.</span><span class=n>returncode</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=4-1><strong>4. <code>subprocess.run()</code> 返回对象</strong></h2><p><code>subprocess.run()</code> 返回 <code>CompletedProcess</code> 对象，该对象包含以下信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span> <span class=n>capture_output</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>args</span><span class=p>)</span>     <span class=c1># [&#39;ls&#39;, &#39;-l&#39;]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>returncode</span><span class=p>)</span>  <span class=c1># 0 (成功) 或非 0（失败）</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>stdout</span><span class=p>)</span>   <span class=c1># 标准输出</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>stderr</span><span class=p>)</span>   <span class=c1># 标准错误</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=5-1><strong>5. <code>subprocess.run()</code> vs <code>subprocess.Popen()</code></strong></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>是否阻塞</strong></th><th><strong>是否可交互</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>subprocess.run()</code></td><td>✅ 阻塞</td><td>❌ 不可交互</td><td>运行简单命令，获取输出</td></tr><tr><td><code>subprocess.Popen()</code></td><td>❌ 非阻塞</td><td>✅ 可交互</td><td>需要实时获取进程状态、交互式命令</td></tr></tbody></table><hr><h2 id=总结><strong>总结</strong></h2><ul><li><strong><code>subprocess.run()</code> 适用于运行命令并等待结果</strong></li><li><strong>可以捕获输出、设置超时、改变工作目录</strong></li><li><strong>对于交互式进程或长期运行的进程，使用 <code>subprocess.Popen()</code></strong></li></ul><p>🚀 <strong>推荐使用 <code>capture_output=True, text=True</code> 获取标准输出</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span> <span class=n>capture_output</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>stdout</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=popen详细用法>Popen详细用法</h2><p><code>subprocess.Popen()</code> 是 Python 用于创建子进程的强大工具，常用于执行外部命令或程序。以下是 <code>Popen</code> 的常用参数及其作用：</p><hr><h3 id=1-2><strong>1. <code>subprocess.Popen()</code> 基本格式</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>(</span><span class=n>args</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>shell</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>stdin</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=2-主要参数解析><strong>2. 主要参数解析</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>args</code></td><td><strong>要执行的命令</strong>，可以是字符串（<code>shell=True</code> 时）或列表（<code>shell=False</code> 时）</td></tr><tr><td><code>shell</code></td><td>是否使用 <strong>shell 解析命令</strong>（默认为 <code>False</code>）。<code>True</code> 时支持 <code>&&</code>、`</td></tr><tr><td><code>stdout</code></td><td><strong>标准输出</strong>，可设为 <code>subprocess.PIPE</code>（捕获输出）、<code>None</code>（直接显示）、文件对象</td></tr><tr><td><code>stderr</code></td><td><strong>标准错误输出</strong>，同 <code>stdout</code></td></tr><tr><td><code>stdin</code></td><td><strong>标准输入</strong>，用于传递输入数据，如 <code>subprocess.PIPE</code></td></tr><tr><td><code>cwd</code></td><td>指定子进程的 <strong>工作目录</strong></td></tr><tr><td><code>env</code></td><td><strong>环境变量</strong>，可传入 <code>dict</code> 来修改默认环境</td></tr><tr><td><code>text / universal_newlines</code></td><td><code>True</code> 时，<code>stdout</code> 和 <code>stderr</code> 返回 <strong>字符串</strong>（默认是字节流）</td></tr><tr><td><code>encoding</code></td><td>指定编码，如 <code>utf-8</code></td></tr><tr><td><code>bufsize</code></td><td><strong>缓冲区大小</strong>，默认为 <code>-1</code>（系统默认），<code>0</code>（无缓冲），<code>1</code>（行缓冲）</td></tr><tr><td><code>executable</code></td><td>指定要执行的二进制文件路径</td></tr><tr><td><code>close_fds</code></td><td><code>True</code> 时关闭子进程的文件描述符（Windows 不支持）</td></tr></tbody></table><hr><h2 id=3-2><strong>3. <code>args</code> 参数示例</strong></h2><h3 id=-推荐shellfalse列表方式>✅ 推荐（<code>shell=False</code>，列表方式）</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>优点</strong>：</p><ul><li><strong>更安全</strong>（避免 <code>shell</code> 命令注入）</li><li><strong>自动处理参数</strong>（如空格、特殊字符）</li></ul><h3 id=-shelltrue字符串方式>⚠️ <code>shell=True</code>（字符串方式）</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>(</span><span class=s2>&#34;ls -l&#34;</span><span class=p>,</span> <span class=n>shell</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于</strong>：</p><ul><li>需要执行 <strong>多个命令</strong>（如 <code>ls -l | grep py</code>）</li><li>需要使用 <strong>shell 变量</strong>（如 <code>$HOME</code>）</li></ul><p><strong>注意</strong>：⚠ <code>shell=True</code> 可能导致 <strong>命令注入风险</strong>，特别是如果 <code>args</code> 是用户输入的内容。</p><hr><h2 id=4-2><strong>4. <code>stdout</code> 和 <code>stderr</code> 捕获</strong></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                           <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>out</span><span class=p>,</span> <span class=n>err</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>communicate</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;标准输出:&#34;</span><span class=p>,</span> <span class=n>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;标准错误:&#34;</span><span class=p>,</span> <span class=n>err</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>stdout=subprocess.PIPE</code>：捕获子进程的 <strong>标准输出</strong></li><li><code>stderr=subprocess.PIPE</code>：捕获子进程的 <strong>错误输出</strong></li><li><code>text=True</code>：自动解码为字符串（默认是字节流）</li></ul><hr><h2 id=5-读取子进程的输出><strong>5. 读取子进程的输出</strong></h2><h3 id=1-3><strong>(1) <code>process.communicate()</code> 方式</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;echo&#34;</span><span class=p>,</span> <span class=s2>&#34;Hello&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                           <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>out</span><span class=p>,</span> <span class=n>err</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>communicate</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>out</span><span class=p>)</span>  <span class=c1># 输出: Hello</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于</strong>：</p><ul><li>一次性读取完整输出</li><li><strong>阻塞</strong> 等待子进程完成</li></ul><hr><h3 id=2-1><strong>(2) <code>process.poll()</code> 轮询检查状态</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;sleep&#34;</span><span class=p>,</span> <span class=s2>&#34;3&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>process</span><span class=o>.</span><span class=n>poll</span><span class=p>()</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;子进程仍在运行...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;子进程已结束&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于</strong>：</p><ul><li>需要在子进程运行时执行其他任务</li><li><strong>非阻塞方式</strong></li></ul><hr><h3 id=3-3><strong>(3) <code>process.wait()</code> 等待子进程结束</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;sleep&#34;</span><span class=p>,</span> <span class=s2>&#34;3&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>process</span><span class=o>.</span><span class=n>wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;子进程已结束&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于</strong>：</p><ul><li><strong>阻塞</strong> 直到子进程完成</li><li>返回 <strong>子进程的退出码</strong></li></ul><hr><h3 id=4-逐行读取子进程输出><strong>(4) 逐行读取子进程输出</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;ping&#34;</span><span class=p>,</span> <span class=s2>&#34;-c&#34;</span><span class=p>,</span> <span class=s2>&#34;4&#34;</span><span class=p>,</span> <span class=s2>&#34;google.com&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                           <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>process</span><span class=o>.</span><span class=n>stdout</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>line</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span>  <span class=c1># 实时打印子进程输出</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于</strong>：</p><ul><li><strong>实时获取子进程输出</strong></li><li>适合 <strong>长期运行的进程</strong></li></ul><hr><h2 id=6><strong>6. <code>stdin</code> 传入数据</strong></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;python&#34;</span><span class=p>,</span> <span class=s2>&#34;-c&#34;</span><span class=p>,</span> <span class=s2>&#34;print(input())&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                           <span class=n>stdin</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>out</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>communicate</span><span class=p>(</span><span class=s2>&#34;Hello World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>out</span><span class=p>)</span>  <span class=c1># 输出: Hello World</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于</strong>：</p><ul><li>需要给子进程提供输入数据</li></ul><hr><h2 id=7-终止子进程><strong>7. 终止子进程</strong></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;sleep&#34;</span><span class=p>,</span> <span class=s2>&#34;10&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>process</span><span class=o>.</span><span class=n>terminate</span><span class=p>()</span>  <span class=c1># 终止进程</span>
</span></span><span class=line><span class=cl><span class=n>process</span><span class=o>.</span><span class=n>wait</span><span class=p>()</span>  <span class=c1># 确保进程结束</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>terminate()</code>：<strong>发送 SIGTERM 终止</strong></li><li><code>kill()</code>：<strong>发送 SIGKILL 强制终止</strong></li><li><code>wait()</code>：<strong>确保进程完全退出</strong></li></ul><hr><h2 id=8-运行带环境变量的命令><strong>8. 运行带环境变量的命令</strong></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>env</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&#34;MY_VAR&#34;</span><span class=p>:</span> <span class=s2>&#34;123&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;printenv&#34;</span><span class=p>,</span> <span class=s2>&#34;MY_VAR&#34;</span><span class=p>],</span> <span class=n>env</span><span class=o>=</span><span class=n>env</span><span class=p>,</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>out</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>communicate</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>out</span><span class=p>)</span>  <span class=c1># 输出: 123</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于</strong>：</p><ul><li>需要给子进程提供特定的环境变量</li></ul><hr><h2 id=9><strong>9. <code>cwd</code> 指定工作目录</strong></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>process</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>],</span> <span class=n>cwd</span><span class=o>=</span><span class=s2>&#34;/tmp&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于</strong>：</p><ul><li>需要在特定目录下执行命令</li></ul><hr><h2 id=10-等待多个子进程><strong>10. 等待多个子进程</strong></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>procs</span> <span class=o>=</span> <span class=p>[</span><span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;sleep&#34;</span><span class=p>,</span> <span class=nb>str</span><span class=p>(</span><span class=n>i</span><span class=p>)])</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>procs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>.</span><span class=n>wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;所有子进程结束&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于</strong>：</p><ul><li>启动多个子进程，并等待它们全部结束</li></ul><hr><h2 id=总结-1><strong>总结</strong></h2><table><thead><tr><th>功能</th><th>关键参数</th><th>代码示例</th></tr></thead><tbody><tr><td><strong>执行命令</strong></td><td><code>args</code></td><td><code>subprocess.Popen(["ls", "-l"])</code></td></tr><tr><td><strong>使用 shell</strong></td><td><code>shell=True</code></td><td><code>subprocess.Popen("ls -l", shell=True)</code></td></tr><tr><td><strong>获取输出</strong></td><td><code>stdout=subprocess.PIPE</code></td><td><code>out, _ = process.communicate()</code></td></tr><tr><td><strong>实时读取输出</strong></td><td><code>for line in process.stdout</code></td><td>见 <strong>逐行读取</strong> 示例</td></tr><tr><td><strong>输入数据</strong></td><td><code>stdin=subprocess.PIPE</code></td><td><code>process.communicate("data")</code></td></tr><tr><td><strong>检查进程状态</strong></td><td><code>process.poll()</code></td><td>见 <strong>轮询检查</strong> 示例</td></tr><tr><td><strong>终止进程</strong></td><td><code>process.terminate()</code></td><td><code>process.kill()</code></td></tr><tr><td><strong>工作目录</strong></td><td><code>cwd="/tmp"</code></td><td><code>subprocess.Popen(["ls"], cwd="/tmp")</code></td></tr><tr><td><strong>环境变量</strong></td><td><code>env={"MY_VAR": "123"}</code></td><td><code>subprocess.Popen(["printenv", "MY_VAR"], env=env)</code></td></tr></tbody></table><p>📌 <strong>推荐</strong>：</p><ul><li><strong>执行外部命令时尽量使用 <code>shell=False</code></strong>（避免安全风险）</li><li><strong>需要返回数据时，<code>stdout=subprocess.PIPE, text=True</code></strong></li><li><strong><code>process.communicate()</code> 适用于一次性读取，<code>for line in process.stdout</code> 适用于实时读取</strong></li></ul><p>这样，你就可以灵活使用 <code>subprocess.Popen()</code> 处理子进程了！🚀</p><h2 id=pcommunicate-vs-ppoll>p.communicate() v.s. p.poll()</h2><p><code>p.communicate()</code> 和 <code>p.poll()</code> 都用于处理 Python <code>subprocess.Popen()</code> 进程，但它们的作用和适用场景不同：</p><table><thead><tr><th>方法</th><th>作用</th><th>是否阻塞</th><th>返回值</th><th>适用场景</th></tr></thead><tbody><tr><td><code>p.communicate()</code></td><td>读取标准输出/标准错误并等待进程结束</td><td>✅ 阻塞</td><td><code>(stdout, stderr)</code></td><td>需要获取完整输出，并等待进程结束</td></tr><tr><td><code>p.poll()</code></td><td>检查进程是否结束，不阻塞</td><td>❌ 非阻塞</td><td><code>None</code>（进行中）或退出码</td><td>需要<strong>非阻塞</strong>地检查进程状态</td></tr></tbody></table><hr><h2 id=1-4><strong>1. <code>p.communicate()</code></strong></h2><p><code>p.communicate()</code> 适用于<strong>一次性获取子进程的完整输出</strong>，同时<strong>等待进程结束</strong>。</p><h3 id=示例-9><strong>示例</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>stdout</span><span class=p>,</span> <span class=n>stderr</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>communicate</span><span class=p>()</span>  <span class=c1># 读取输出并等待进程结束</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;STDOUT:&#34;</span><span class=p>,</span> <span class=n>stdout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;STDERR:&#34;</span><span class=p>,</span> <span class=n>stderr</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=特点-5><strong>特点</strong></h3><ul><li><strong>会阻塞（等待进程结束）</strong></li><li><strong>一次性读取 <code>stdout</code> 和 <code>stderr</code></strong></li><li><strong>防止死锁（避免 <code>stdout</code> 或 <code>stderr</code> 缓冲区溢出）</strong></li></ul><hr><h2 id=2-2><strong>2. <code>p.poll()</code></strong></h2><p><code>p.poll()</code> 适用于<strong>非阻塞地检查进程是否结束</strong>，它不会等待进程结束，而是立即返回进程状态。</p><h3 id=示例-10><strong>示例</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;sleep&#34;</span><span class=p>,</span> <span class=s2>&#34;5&#34;</span><span class=p>])</span>  <span class=c1># 执行一个 5 秒的命令</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>retcode</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>poll</span><span class=p>()</span>  <span class=c1># 检查进程状态</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>retcode</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;进程结束，退出码：&#34;</span><span class=p>,</span> <span class=n>retcode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;进程仍在运行...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># 每秒检查一次</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=特点-6><strong>特点</strong></h3><ul><li><strong>不会阻塞</strong></li><li><strong>仅返回进程状态</strong></li><li><strong>如果进程结束，返回退出码；否则返回 <code>None</code></strong></li></ul><hr><h2 id=3-何时用><strong>3. 何时用 <code>p.communicate()</code>，何时用 <code>p.poll()</code>？</strong></h2><ul><li><strong>如果你需要获取进程输出并等待进程结束</strong>，用 <code>p.communicate()</code>。</li><li><strong>如果你只想检查进程是否结束（但不阻塞）</strong>，用 <code>p.poll()</code>。</li></ul><hr><h2 id=4-3><strong>4. <code>p.communicate()</code> vs <code>p.poll()</code> 综合示例</strong></h2><p>如果需要<strong>非阻塞地检查进程状态，并在进程结束后获取输出</strong>，可以组合使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;ls&#34;</span><span class=p>,</span> <span class=s2>&#34;-l&#34;</span><span class=p>],</span> <span class=n>stdout</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>stderr</span><span class=o>=</span><span class=n>subprocess</span><span class=o>.</span><span class=n>PIPE</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>p</span><span class=o>.</span><span class=n>poll</span><span class=p>()</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>  <span class=c1># 进程还在运行</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;进程运行中...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>stdout</span><span class=p>,</span> <span class=n>stderr</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>communicate</span><span class=p>()</span>  <span class=c1># 进程结束后获取输出</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;STDOUT:&#34;</span><span class=p>,</span> <span class=n>stdout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;STDERR:&#34;</span><span class=p>,</span> <span class=n>stderr</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=总结-2><strong>总结</strong></h2><table><thead><tr><th>方法</th><th>作用</th><th>是否阻塞</th><th>返回值</th><th>适用场景</th></tr></thead><tbody><tr><td><code>p.communicate()</code></td><td>读取标准输出/错误并等待进程结束</td><td>✅ 阻塞</td><td><code>(stdout, stderr)</code></td><td>需要获取完整输出，并等待进程结束</td></tr><tr><td><code>p.poll()</code></td><td>检查进程是否结束</td><td>❌ 非阻塞</td><td><code>None</code>（运行中）或退出码</td><td>需要<strong>非阻塞</strong>检查进程状态</td></tr></tbody></table><p>🚀 <strong>最佳实践</strong></p><ul><li><strong><code>p.poll()</code> 适用于需要非阻塞检查进程是否结束</strong></li><li><strong><code>p.communicate()</code> 适用于获取子进程的输出并等待完成</strong></li><li><strong>如果进程可能输出大量数据，建议使用 <code>p.communicate()</code> 避免缓冲区溢出</strong></li></ul><h1 id=command-lines>command lines</h1><p>在 Python 中，判断脚本是否在终端中执行的方式可以是通过检查标准输入、输出是否连接到终端。<br>可以使用 sys.stdin.isatty() 来检查标准输入是否连接到终端，以及 sys.stdout.isatty() 来检查标准输出是否连接到终端。</p><p>以下是一个示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_running_in_terminal</span><span class=p>():</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>sys</span><span class=o>.</span><span class=n>stdin</span><span class=o>.</span><span class=n>isatty</span><span class=p>()</span> <span class=ow>and</span> <span class=n>sys</span><span class=o>.</span><span class=n>stdout</span><span class=o>.</span><span class=n>isatty</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>is_running_in_terminal</span><span class=p>():</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Running in a terminal.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Not running in a terminal.&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>在终端中执行时，sys.stdin.isatty() 和 sys.stdout.isatty() 通常都返回 True，而在非终端环境中返回 False。</p><p>请注意，这种方法可能不是绝对可靠的，因为在一些特殊情况下，即使在终端中运行，也可能返回 False。这主要取决于操作系统和环境。</p><h1 id=open-source>open source</h1><p><a href=https://zhuanlan.zhihu.com/p/408472691 target=_blank rel="noopener noreffer">GitHub Top 10 + Python 开源项目（2021版</a></p><p><a href=https://juejin.cn/post/6959702319558557726#heading-1 target=_blank rel="noopener noreffer">强烈推荐：GitHub 上开源的 13 个 Python 资源 - 掘金</a></p><p><a href=https://www.cnblogs.com/livelab/p/14041267.html target=_blank rel="noopener noreffer">推荐11个值得研究学习的Python开源项目(从入门到python高级开发) - GlaryJoker - 博客园</a></p><p><a href=https://zhuanlan.zhihu.com/p/280039778 target=_blank rel="noopener noreffer">GitHub 上适合新手的开源项目（Python 篇）</a></p><h1 id=noqa>noqa</h1><p>在 Python 深度学习代码中，<code># noqa</code> 是 <strong>Flake8</strong> 代码检查工具的一种指令，用于<strong>忽略特定代码行的警告或错误</strong>。</p><h3 id=heading><strong>📌 <code># noqa</code> 作用</strong></h3><p><code># noqa</code> 全称是 <strong>&ldquo;No Quality Assurance&rdquo;</strong>，主要用于**抑制静态代码分析工具（如 Flake8、pylint）**检测到的错误。例如，在深度学习代码中，可能遇到以下情况：</p><h3 id=1-忽略未使用的导入><strong>1️⃣ 忽略未使用的导入</strong></h3><p>在 PyTorch 或 TensorFlow 代码中，某些导入可能仅用于装饰器或动态加载，但 Flake8 可能会报 <code>F401 'XXX' imported but unused</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch</span>  <span class=c1># noqa</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch.nn</span> <span class=k>as</span> <span class=nn>nn</span>  <span class=c1># noqa: F401</span>
</span></span></code></pre></td></tr></table></div></div><p>✅ 这样可以防止 Flake8 报告未使用的导入。</p><hr><h3 id=2-忽略长行超出-7988-字符限制><strong>2️⃣ 忽略长行超出 79/88 字符限制</strong></h3><p>如果代码行超过 PEP8 规定的 79 或 88 个字符（比如复杂的神经网络定义），可以使用 <code># noqa</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>model</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Sequential</span><span class=p>(</span><span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=mi>512</span><span class=p>,</span> <span class=mi>256</span><span class=p>),</span> <span class=n>nn</span><span class=o>.</span><span class=n>ReLU</span><span class=p>(),</span> <span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=mi>256</span><span class=p>,</span> <span class=mi>128</span><span class=p>))</span>  <span class=c1># noqa</span>
</span></span></code></pre></td></tr></table></div></div><hr><h3 id=3-忽略><strong>3️⃣ 忽略 <code>E402</code>（导入不在文件顶部）</strong></h3><p>有时为了兼容 TensorFlow 或 PyTorch 设备初始化，可能会在导入之前进行某些设置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s2>&#34;CUDA_VISIBLE_DEVICES&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;0&#34;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch</span>  <span class=c1># noqa: E402</span>
</span></span></code></pre></td></tr></table></div></div><p>✅ <code># noqa: E402</code> 让 Flake8 忽略导入不在顶部的错误。</p><hr><h3 id=heading-1><strong>💡 <code># noqa</code> 在深度学习中的常见场景</strong></h3><table><thead><tr><th>场景</th><th><code>noqa</code> 代码示例</th></tr></thead><tbody><tr><td>忽略未使用的导入</td><td><code>import torch # noqa: F401</code></td></tr><tr><td>忽略长行警告</td><td><code>model = nn.Sequential(...) # noqa</code></td></tr><tr><td>忽略导入顺序警告</td><td><code>import torch # noqa: E402</code></td></tr><tr><td>忽略变量未使用</td><td><code>_ = torch.randn(1) # noqa: F841</code></td></tr></tbody></table><hr><h3 id=-总结><strong>🚀 总结</strong></h3><ol><li><code># noqa</code> 用于<strong>忽略 Flake8/Pylint 代码检查</strong>。</li><li><strong>常见于深度学习代码</strong>，用于跳过未使用的导入（如 <code>torch</code>, <code>tensorflow</code>）、长行警告等。</li><li>可以指定错误代码，如 <code># noqa: F401</code> 仅忽略 <strong>未使用导入</strong>，避免忽略其他潜在错误。</li></ol><p>如果你在深度学习项目中看到 <code># noqa</code>，通常是为了让代码格式检查工具不报错，而不会影响代码的运行。 🚀</p><h1 id=pythonpath>PYTHONPATH</h1><p>在 <strong>Shell</strong> 中执行 Python 脚本时，如果遇到 <code>ModuleNotFoundError</code>，很可能是 <strong><code>PYTHONPATH</code> 没有正确设置</strong>，导致 Python 无法找到模块或包。下面是一些常见的解决方法：</p><hr><h2 id=1-直接在-shell-中临时设置><strong>1. 直接在 Shell 中临时设置 <code>PYTHONPATH</code></strong></h2><p>如果你的 Python 模块位于 <code>/home/user/my_project/</code>，那么可以在运行 Python 脚本时手动指定 <code>PYTHONPATH</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PYTHONPATH</span><span class=o>=</span>/home/user/my_project:<span class=nv>$PYTHONPATH</span>
</span></span><span class=line><span class=cl>python your_script.py
</span></span></code></pre></td></tr></table></div></div><p>或者直接一行执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>PYTHONPATH</span><span class=o>=</span>/home/user/my_project python your_script.py
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于：</strong> 临时解决路径问题，每次新开终端都需要重新设置。</p><hr><h2 id=2-在-python-代码中手动添加><strong>2. 在 Python 代码中手动添加 <code>sys.path</code></strong></h2><p>如果你不想手动设置环境变量，可以在 <code>your_script.py</code> 代码顶部添加：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;/home/user/my_project&#39;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于：</strong> 代码可控的情况，适用于多个环境，但需要手动修改代码。</p><hr><h2 id=3-直接使用当前工作目录><strong>3. 直接使用当前工作目录</strong></h2><p>如果你希望 Python 搜索当前目录，可以使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PYTHONPATH</span><span class=o>=</span><span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span>:<span class=nv>$PYTHONPATH</span>
</span></span><span class=line><span class=cl>python your_script.py
</span></span></code></pre></td></tr></table></div></div><p>或者：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>PYTHONPATH</span><span class=o>=</span><span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span> python your_script.py
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于：</strong> 代码和模块都在当前目录及其子目录下。</p><hr><h2 id=4-在><strong>4. 在 <code>.bashrc</code> / <code>.bash_profile</code> / <code>.zshrc</code> 中永久设置 <code>PYTHONPATH</code></strong></h2><p>如果 <code>ModuleNotFoundError</code> 频繁发生，可以把 <code>PYTHONPATH</code> 添加到 <code>~/.bashrc</code> 或 <code>~/.zshrc</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s1>&#39;export PYTHONPATH=/home/user/my_project:$PYTHONPATH&#39;</span> &gt;&gt; ~/.bashrc
</span></span><span class=line><span class=cl><span class=nb>source</span> ~/.bashrc  <span class=c1># 使其生效</span>
</span></span></code></pre></td></tr></table></div></div><p>对于 <code>zsh</code>（Mac 或部分 Linux 发行版）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s1>&#39;export PYTHONPATH=/home/user/my_project:$PYTHONPATH&#39;</span> &gt;&gt; ~/.zshrc
</span></span><span class=line><span class=cl><span class=nb>source</span> ~/.zshrc
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于：</strong> 需要长期使用某个 Python 项目，不想每次手动设置 <code>PYTHONPATH</code>。</p><hr><h2 id=5-确保><strong>5. 确保 <code>python</code> 解释器正确</strong></h2><p>有时 <code>ModuleNotFoundError</code> 可能是因为使用了错误的 Python 解释器。在 Shell 中运行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>which python
</span></span><span class=line><span class=cl>which python3
</span></span><span class=line><span class=cl>python --version
</span></span><span class=line><span class=cl>python3 --version
</span></span></code></pre></td></tr></table></div></div><p>如果你的项目使用虚拟环境（venv / conda），确保你激活了它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>source</span> venv/bin/activate  <span class=c1># venv/virtualenv</span>
</span></span><span class=line><span class=cl>conda activate my_env     <span class=c1># conda</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>适用于：</strong> 确保使用正确的 Python 解释器。</p><hr><h2 id=6-通过><strong>6. 通过 <code>sys.path</code> 检查 <code>PYTHONPATH</code></strong></h2><p>你可以在 Python 交互模式或脚本中执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>检查 <code>PYTHONPATH</code> 是否包含你的模块路径。如果缺失，就需要手动添加或设置。</p><hr><h2 id=总结-3><strong>总结</strong></h2><table><thead><tr><th>方案</th><th>适用场景</th><th>方式</th></tr></thead><tbody><tr><td>1. <code>export PYTHONPATH=路径</code></td><td>临时解决，手动执行</td><td><code>export</code> 或 <code>PYTHONPATH=xxx python script.py</code></td></tr><tr><td>2. <code>sys.path.append()</code></td><td>代码可控，可跨环境</td><td>在 Python 脚本中添加</td></tr><tr><td>3. <code>PYTHONPATH=$(pwd)</code></td><td>当前目录搜索模块</td><td>适用于单次运行</td></tr><tr><td>4. <code>~/.bashrc</code> / <code>~/.zshrc</code></td><td>长期使用某路径</td><td>添加 <code>export PYTHONPATH=xxx</code></td></tr><tr><td>5. 确保 <code>python</code> 解释器正确</td><td>可能是错误的 Python 版本</td><td><code>which python</code> 检查</td></tr><tr><td>6. 检查 <code>sys.path</code></td><td>确认 <code>PYTHONPATH</code> 生效</td><td><code>print(sys.path)</code></td></tr></tbody></table><p>试试看这些方法，应该可以解决你的 <code>ModuleNotFoundError</code> 问题！🚀</p><h2 id=pythonpath-vs-syspath>PYTHONPATH vs. sys.path</h2><p><code>sys.path</code> 和 <code>PYTHONPATH</code> 都用于 <strong>影响 Python 解释器查找模块的路径</strong>，但它们的作用方式有所不同。</p><hr><h2 id=1-5><strong>1. <code>sys.path</code> 是 Python 解释器的模块搜索路径</strong></h2><ul><li><p><code>sys.path</code> 是一个 <strong>列表</strong>，包含 Python 解释器搜索模块时会参考的所有目录路径。</p></li><li><p>可以在 Python 代码中直接访问和修改：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=p>)</span>  <span class=c1># 输出当前的模块搜索路径</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>可以手动添加新的搜索路径：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;/home/user/my_project&#39;</span><span class=p>)</span>  <span class=c1># 追加新的搜索路径</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><hr><h2 id=2-3><strong>2. <code>PYTHONPATH</code> 是环境变量，影响 <code>sys.path</code></strong></h2><ul><li><p><code>PYTHONPATH</code> 是 <strong>Shell 环境变量</strong>，当 Python 启动时，它的值会被自动添加到 <code>sys.path</code>。</p></li><li><p>可以在 Shell 中设置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PYTHONPATH</span><span class=o>=</span>/home/user/my_project:<span class=nv>$PYTHONPATH</span>
</span></span><span class=line><span class=cl>python script.py
</span></span></code></pre></td></tr></table></div></div><p>这样，Python 启动时 <code>/home/user/my_project</code> 目录就会被加入 <code>sys.path</code>。</p></li></ul><hr><h2 id=3-4><strong>3. <code>sys.path</code> 和 <code>PYTHONPATH</code> 的关系</strong></h2><ul><li><strong><code>PYTHONPATH</code> 的值会被 Python 启动时添加到 <code>sys.path</code>。</strong></li><li><strong><code>sys.path</code> 包含了默认的 Python 解释器搜索路径（如 <code>site-packages</code>）+ <code>PYTHONPATH</code> 变量中的路径 + 运行脚本所在目录。</strong></li><li>修改 <code>sys.path</code> 只影响当前 Python 进程，而 <code>PYTHONPATH</code> 影响整个 Shell 会话或系统环境。</li></ul><hr><h2 id=4-4><strong>4. <code>sys.path</code> 组成</strong></h2><p>通常，<code>sys.path</code> 包括以下几部分：</p><ol><li><strong>运行脚本的目录</strong>（即 <code>''</code> 或 <code>.</code>）。</li><li><strong>标准库路径</strong>（例如 <code>/usr/lib/python3.x</code>）。</li><li><strong>site-packages</strong>（第三方库的安装目录）。</li><li><strong><code>PYTHONPATH</code> 变量指定的路径</strong>（如果有）。</li><li><strong>其他特殊路径</strong>（某些 Python 发行版可能会额外添加）。</li></ol><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>可能输出：</p><pre tabindex=0><code>/home/user/my_project
/usr/lib/python3.8
/usr/lib/python3.8/lib-dynload
/usr/local/lib/python3.8/dist-packages
</code></pre><hr><h2 id=5-何时使用><strong>5. 何时使用 <code>PYTHONPATH</code> vs <code>sys.path</code>？</strong></h2><table><thead><tr><th>方式</th><th>适用场景</th><th>作用范围</th><th>影响时间</th></tr></thead><tbody><tr><td><code>PYTHONPATH</code></td><td>设置 Python 解释器的全局搜索路径</td><td>影响所有 Python 进程</td><td>Python 启动时生效</td></tr><tr><td><code>sys.path.append()</code></td><td>仅影响当前 Python 进程</td><td>仅当前 Python 运行时</td><td>运行时动态生效</td></tr></tbody></table><hr><h2 id=6-选择使用><strong>6. 选择使用 <code>PYTHONPATH</code> 还是 <code>sys.path</code>？</strong></h2><p>✅ <strong>适合用 <code>PYTHONPATH</code>：</strong></p><ul><li>你需要全局（长期）设置 Python 搜索路径（如添加某个项目路径）。</li><li>你希望在 <strong>Shell</strong> 中运行 Python 时自动生效（适用于 Docker、远程服务器等）。</li><li>你在 <code>.bashrc</code> 或 <code>.zshrc</code> 中配置了 <code>PYTHONPATH</code> 以持久化路径。</li></ul><p>✅ <strong>适合用 <code>sys.path</code>：</strong></p><ul><li>你只想在 <strong>当前 Python 进程</strong> 中临时添加路径，而不影响其他 Python 进程。</li><li>你的脚本会被不同环境运行，手动修改 <code>sys.path.append()</code> 更灵活。</li><li>你在 Jupyter Notebook 或动态环境中，临时需要额外路径。</li></ul><hr><h2 id=7-示例两种方式的使用><strong>7. 示例：两种方式的使用</strong></h2><h3 id=方式-1使用><strong>方式 1：使用 <code>PYTHONPATH</code>（推荐长期设置）</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PYTHONPATH</span><span class=o>=</span>/home/user/my_project:<span class=nv>$PYTHONPATH</span>
</span></span><span class=line><span class=cl>python my_script.py
</span></span></code></pre></td></tr></table></div></div><p>这会在 <strong>Python 启动时</strong> 将 <code>/home/user/my_project</code> 加入 <code>sys.path</code>。</p><h3 id=方式-2使用><strong>方式 2：使用 <code>sys.path.append()</code>（推荐短期/动态修改）</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;/home/user/my_project&#39;</span><span class=p>)</span>  <span class=c1># 运行时生效</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>my_module</span>  <span class=c1># 现在可以导入这个目录下的模块</span>
</span></span></code></pre></td></tr></table></div></div><p>适用于脚本内部动态修改，而不影响全局 Python 解释器。</p><hr><h2 id=总结-4><strong>总结</strong></h2><ul><li><strong><code>PYTHONPATH</code> 影响 <code>sys.path</code>，但 <code>sys.path</code> 也可以在运行时动态修改。</strong></li><li><strong>如果要全局长期修改 Python 搜索路径，用 <code>PYTHONPATH</code>（适用于环境配置）。</strong></li><li><strong>如果只是临时修改某个 Python 进程的路径，用 <code>sys.path.append()</code>（适用于代码内部）。</strong></li></ul><h3 id=-最佳实践>🚀 <strong>最佳实践</strong></h3><ol><li><strong>开发环境</strong>：在 Shell 设置 <code>PYTHONPATH</code>，减少 <code>sys.path.append()</code> 的使用。</li><li><strong>脚本运行</strong>：如果需要动态修改路径，使用 <code>sys.path.append()</code>。</li><li><strong>生产环境</strong>：确保 <code>PYTHONPATH</code> 在 <code>.bashrc</code> / <code>.zshrc</code> 中配置好，避免硬编码 <code>sys.path.append()</code>。</li></ol><p>这样可以确保 Python 代码在不同环境下都能正确导入模块！ ✅</p><h2 id=append-vs-insert0>append v.s. insert(0)</h2><p>在 Python 中，<code>sys.path.append(path)</code> 和 <code>sys.path.insert(0, path)</code> 都用于动态添加模块搜索路径，但它们的<strong>优先级</strong>和<strong>行为</strong>有显著差异。以下是详细对比：</p><hr><h3 id=1-核心区别>1. <strong>核心区别</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>行为</strong></th></tr></thead><tbody><tr><td><code>sys.path.append(path)</code></td><td>将路径 <strong>追加到 <code>sys.path</code> 列表的末尾</strong>，优先级最低。</td></tr><tr><td><code>sys.path.insert(0, path)</code></td><td>将路径 <strong>插入到 <code>sys.path</code> 列表的最前面</strong>，优先级最高。</td></tr></tbody></table><hr><h3 id=2-优先级对模块导入的影响>2. <strong>优先级对模块导入的影响</strong></h3><p>Python 解释器按 <code>sys.path</code> 的顺序搜索模块。假设存在以下路径：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;/usr/lib/python3.8&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;/usr/local/lib/python3.8&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=场景-1使用-append>场景 1：使用 <code>append</code></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>&#34;/custom/path&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>新路径 <code>/custom/path</code> 会被添加到列表末尾。</li><li><strong>优先级</strong>：系统路径 > 用户路径。</li><li><strong>适用场景</strong>：希望优先使用系统默认模块，仅在必要时使用自定义路径。</li></ul><h3 id=场景-2使用-insert0->场景 2：使用 <code>insert(0, ...)</code></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s2>&#34;/custom/path&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>新路径 <code>/custom/path</code> 会被插入到列表最前面。</li><li><strong>优先级</strong>：用户路径 > 系统路径。</li><li><strong>适用场景</strong>：希望覆盖系统模块（例如自定义同名模块）或强制优先加载本地代码。</li></ul><hr><h3 id=3-实际示例>3. <strong>实际示例</strong></h3><p>假设目录结构如下：</p><pre tabindex=0><code>project/
├── main.py
└── my_package/
    └── module.py
</code></pre><h3 id=31-使用-append>3.1 使用 <code>append</code></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>&#34;/path/to/project/my_package&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>module</span>  <span class=c1># 会搜索到 my_package/module.py</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>风险</strong>：如果系统中存在同名模块（如 <code>module</code>），且路径在 <code>/path/to/project/my_package</code> 之前，会优先导入系统模块。</li></ul><h3 id=32-使用-insert>3.2 使用 <code>insert</code></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s2>&#34;/path/to/project/my_package&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>module</span>  <span class=c1># 确保导入的是 my_package/module.py</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>优势</strong>：强制优先使用自定义路径中的模块，避免命名冲突。</li></ul><hr><h3 id=4-选择标准>4. <strong>选择标准</strong></h3><table><thead><tr><th><strong>需求</strong></th><th><strong>推荐方法</strong></th></tr></thead><tbody><tr><td>需要覆盖系统或第三方模块</td><td><code>sys.path.insert(0, path)</code></td></tr><tr><td>仅补充额外路径（不影响现有逻辑）</td><td><code>sys.path.append(path)</code></td></tr></tbody></table><hr><h3 id=5-注意事项>5. <strong>注意事项</strong></h3><ol><li><strong>临时性</strong>：两种方法仅对当前 Python 进程有效，脚本结束后失效。</li><li><strong>路径冲突</strong>：插入高优先级路径可能导致意外覆盖系统模块（例如自定义 <code>os.py</code> 会覆盖标准库 <code>os</code> 模块）。</li><li><strong>可维护性</strong>：频繁修改 <code>sys.path</code> 可能导致代码难以维护，建议优先使用虚拟环境（<code>venv</code>）或安装模块到全局路径。</li></ol><hr><h3 id=6-替代方案>6. <strong>替代方案</strong></h3><ul><li><p><strong>设置 <code>PYTHONPATH</code> 环境变量</strong>（全局生效）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PYTHONPATH</span><span class=o>=</span>/custom/path:<span class=nv>$PYTHONPATH</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>使用相对导入</strong>：在包内使用 <code>from . import module</code>。</p></li><li><p><strong>安装模块到全局环境</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip install -e /path/to/package  <span class=c1># 开发模式安装</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><hr><h3 id=总结-5>总结</h3><ul><li><strong><code>append</code></strong>：保守添加路径，避免干扰现有模块。</li><li><strong><code>insert(0, ...)</code></strong>：强制优先加载指定路径，适用于调试或覆盖默认行为。</li></ul><h1 id=shebang语法>shebang语法</h1><p>在 Python 中使用子进程时，是否推荐使用 <strong>shebang</strong> 语法取决于你具体的场景和需求。下面我将详细解释 <strong>shebang</strong> 语法及其在子进程调用中的适用性。</p><hr><h2 id=-什么是-shebang>🔍 <strong>什么是 shebang？</strong></h2><p><strong>shebang（#!）</strong> 是一种用于指明脚本文件解释器的语法。例如，<code>#!/usr/bin/env python3</code> 指定该脚本应使用 <code>python3</code> 来执行。它通常放在文件的第一行，作用是告诉操作系统用哪个解释器来执行脚本。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello, World!&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>在 Linux 和 macOS 上，这行会告诉操作系统用 <code>python3</code> 解释器来执行该文件。</p><hr><h2 id=-shebang-在子进程中的使用场景>🧑‍💻 <strong>shebang 在子进程中的使用场景</strong></h2><h3 id=1-子进程执行-python-脚本>1. <strong>子进程执行 Python 脚本</strong></h3><p>如果你从 Python 中调用另一个 Python 脚本（例如，使用 <code>subprocess</code> 模块），并且你希望该脚本能够正确使用指定的解释器执行，使用 shebang 是非常有意义的。</p><p>假设你有一个名为 <code>my_script.py</code> 的 Python 脚本，它的第一行是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python3</span>
</span></span></code></pre></td></tr></table></div></div><p>然后，你在父进程中使用 <code>subprocess.Popen()</code> 调用它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;./my_script.py&#34;</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=为什么需要-shebang><strong>为什么需要 shebang？</strong></h3><ul><li>如果你在脚本文件中包含了 shebang，操作系统会根据该行的解释器路径来执行脚本。因此，即使你没有显式指定 Python 解释器，操作系统会自动选择正确的解释器。</li><li>如果你使用相对路径执行该脚本（例如，<code>./my_script.py</code>），而没有提供完整的解释器路径，shebang 会确保脚本被正确执行。</li></ul><hr><h3 id=2-python-子进程调用外部程序>2. <strong>Python 子进程调用外部程序</strong></h3><p>在某些情况下，你可能希望通过 <code>subprocess</code> 调用其他 Python 程序（或者外部程序），而不是执行当前 Python 文件。此时，你可能需要手动指定解释器或使用环境变量。</p><p>例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 shebang 自动选择 Python 解释器</span>
</span></span><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;/usr/bin/env&#34;</span><span class=p>,</span> <span class=s2>&#34;python3&#34;</span><span class=p>,</span> <span class=s2>&#34;other_script.py&#34;</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>如果你已经在目标脚本中指定了 shebang，你甚至可以跳过显式指定 Python 解释器，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;./other_script.py&#34;</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>（前提是目标脚本的权限已设置为可执行，并且你在其中包含了正确的 shebang。）</p><hr><h2 id=-注意事项>⚠️ <strong>注意事项</strong></h2><ol><li><p><strong>确保脚本可执行</strong></p><ul><li><p>使用 shebang 时，目标 Python 脚本需要具有执行权限。你可以使用 <code>chmod</code> 命令设置执行权限：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>chmod +x my_script.py
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p><strong>平台差异</strong></p><ul><li><code>#!/usr/bin/env python3</code> 是跨平台的，但它依赖于操作系统环境，因此在不同平台上可能有不同的行为。确保你的操作系统中正确安装了 Python 解释器。</li></ul></li><li><p><strong>不使用 shebang 的情况</strong></p><ul><li><p>如果你不打算将脚本作为独立程序运行，而只是作为子进程中的一部分运行，那么可以在 <code>subprocess.Popen()</code> 中明确指定解释器路径，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>subprocess</span><span class=o>.</span><span class=n>Popen</span><span class=p>([</span><span class=s2>&#34;python3&#34;</span><span class=p>,</span> <span class=s2>&#34;my_script.py&#34;</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>这时，shebang 就不再必要了。</p></li></ul></li></ol><hr><h2 id=-是否推荐使用-shebang>✅ <strong>是否推荐使用 shebang？</strong></h2><ul><li><strong>推荐</strong>：如果你希望在不同环境下执行 Python 脚本，并且该脚本可能独立运行，使用 shebang 会使得脚本更具可移植性，尤其是在 Linux/macOS 上。</li><li><strong>不推荐</strong>：如果你在 Python 内部通过 <code>subprocess</code> 调用其他 Python 脚本，并且明确知道解释器路径或使用的是虚拟环境，那么不一定需要使用 shebang，可以直接指定解释器路径。</li></ul><hr><h3 id=-总结-1>👌 <strong>总结</strong></h3><ul><li>如果你的 Python 脚本需要作为独立脚本运行或者有子进程调用，可以使用 shebang 语法。</li><li>使用 <code>subprocess.Popen()</code> 时，shebang 可以简化命令，自动选择解释器，但也可以直接在父进程中指定 Python 解释器。</li></ul><h1 id=包引用>包引用</h1><h2 id=deepseek>deepseek</h2><p>在Python项目中，若要在多个子目录及次级子目录中正确导入根目录下的模块，可采用以下步骤：</p><h3 id=方法一动态添加根目录到syspath>方法一：动态添加根目录到sys.path</h3><ol><li><strong>在项目根目录创建标记文件</strong>（如<code>.project_root</code>），以便识别根目录。</li><li><strong>在各子模块中动态计算根目录路径</strong>，并将其添加到<code>sys.path</code>中。</li></ol><p><strong>示例代码（子模块中）：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pathlib</span> <span class=kn>import</span> <span class=n>Path</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_root_dir</span><span class=p>(</span><span class=n>start_path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=n>start_path</span><span class=p>)</span><span class=o>.</span><span class=n>resolve</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 寻找包含.project_root的目录</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=ow>not</span> <span class=p>(</span><span class=n>current</span> <span class=o>/</span> <span class=s1>&#39;.project_root&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>exists</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current</span><span class=o>.</span><span class=n>parent</span> <span class=o>==</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>RuntimeError</span><span class=p>(</span><span class=s2>&#34;Project root not found.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>parent</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>current</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取根目录并添加到sys.path</span>
</span></span><span class=line><span class=cl><span class=n>root_dir</span> <span class=o>=</span> <span class=n>find_root_dir</span><span class=p>(</span><span class=vm>__file__</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nb>str</span><span class=p>(</span><span class=n>root_dir</span><span class=p>)</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>root_dir</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 导入根目录下的模块</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>core_utils</span> <span class=kn>import</span> <span class=n>some_function</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=方法二设置pythonpath环境变量>方法二：设置PYTHONPATH环境变量</h3><p>在运行脚本前，将项目根目录添加到<code>PYTHONPATH</code>中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Linux/macOS</span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PYTHONPATH</span><span class=o>=</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>PYTHONPATH</span><span class=si>}</span><span class=s2>:/path/to/project_root&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Windows</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> <span class=nv>PYTHONPATH</span><span class=o>=</span>%PYTHONPATH%<span class=p>;</span>C:<span class=se>\\</span>path<span class=se>\\</span>to<span class=se>\\</span>project_root
</span></span></code></pre></td></tr></table></div></div><p>或在脚本中动态设置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;/path/to/project_root&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>core_utils</span> <span class=kn>import</span> <span class=n>some_function</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=方法三使用可编辑安装推荐用于复杂项目>方法三：使用可编辑安装（推荐用于复杂项目）</h3><ol><li><strong>创建<code>setup.py</code>或使用<code>pyproject.toml</code>配置项目</strong>。</li><li><strong>执行可编辑安装</strong>：</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip install -e .
</span></span></code></pre></td></tr></table></div></div><p>安装后，所有模块可通过包名导入：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>project_name.core_utils</span> <span class=kn>import</span> <span class=n>some_function</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=目录结构示例>目录结构示例</h3><pre tabindex=0><code>project_root/
├── .project_root    # 标记文件
├── core_utils.py
├── subdir1/
│   ├── __init__.py
│   └── module1.py
└── subdir2/
    ├── __init__.py
    └── nested_subdir/
        ├── __init__.py
        └── module2.py
</code></pre><h3 id=总结-6>总结</h3><ul><li><strong>简单项目</strong>：使用方法一，动态添加路径，灵活且无需额外配置。</li><li><strong>团队协作/复杂项目</strong>：使用方法三，通过可编辑安装实现标准化导入。</li><li><strong>快速测试/临时使用</strong>：使用方法二，临时设置环境变量。</li></ul><p>确保所有子模块在导入前正确设置根目录路径，即可跨目录层级正确导入核心模块。</p><h2 id=qwen-1>qwen</h2><p>要在多个子目录及次级子目录中正确导入根目录下的 <code>core_utils.py</code>，可以采用以下方法：</p><h3 id=方法一动态添加根目录到-syspath>方法一：动态添加根目录到 <code>sys.path</code></h3><p>在每个需要导入的子模块中，动态计算根目录路径并添加到 <code>sys.path</code>。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pathlib</span> <span class=kn>import</span> <span class=n>Path</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取当前文件的绝对路径</span>
</span></span><span class=line><span class=cl><span class=n>current_file</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=vm>__file__</span><span class=p>)</span><span class=o>.</span><span class=n>resolve</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 计算根目录路径（根据实际层级调整 parent 的次数）</span>
</span></span><span class=line><span class=cl><span class=n>root_dir</span> <span class=o>=</span> <span class=n>current_file</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>parent</span>  <span class=c1># 假设子目录是两级深（如 app/module1/）</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将根目录添加到系统路径</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>str</span><span class=p>(</span><span class=n>root_dir</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 导入 core_utils</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>core_utils</span> <span class=kn>import</span> <span class=n>some_function</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>注意</strong>：根据子目录的层级调整 <code>.parent</code> 的次数。例如，若脚本在 <code>app/module2/submodule/</code>，则可能需要 <code>parent.parent.parent.parent</code>。</p><hr><h3 id=方法二自动查找根目录>方法二：自动查找根目录</h3><p>编写函数自动向上查找包含 <code>core_utils.py</code> 的根目录：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pathlib</span> <span class=kn>import</span> <span class=n>Path</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_root</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=vm>__file__</span><span class=p>)</span><span class=o>.</span><span class=n>resolve</span><span class=p>()</span><span class=o>.</span><span class=n>parent</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>current</span> <span class=o>!=</span> <span class=n>current</span><span class=o>.</span><span class=n>parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>current</span> <span class=o>/</span> <span class=s1>&#39;core_utils.py&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>exists</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>current</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>parent</span>
</span></span><span class=line><span class=cl>    <span class=k>raise</span> <span class=ne>FileNotFoundError</span><span class=p>(</span><span class=s2>&#34;Root directory with core_utils.py not found.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>str</span><span class=p>(</span><span class=n>find_root</span><span class=p>()))</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>core_utils</span> <span class=kn>import</span> <span class=n>some_function</span>
</span></span></code></pre></td></tr></table></div></div><p>此方法自动定位根目录，无需手动调整路径层级。</p><hr><h3 id=方法三使用相对导入需包结构>方法三：使用相对导入（需包结构）</h3><p>将项目重构为包结构，确保所有目录包含 <code>__init__.py</code> 文件：</p><pre tabindex=0><code>project_root/
├── __init__.py
├── core_utils.py
└── app/
    ├── __init__.py
    ├── module1/
    │   ├── __init__.py
    │   └── script1.py
    └── module2/
        └── submodule/
            └── script2.py
</code></pre><p>在 <code>script1.py</code> 中使用相对导入：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>..core_utils</span> <span class=kn>import</span> <span class=n>some_function</span>  <span class=c1># 需作为模块运行（如 python -m app.module1.script1）</span>
</span></span></code></pre></td></tr></table></div></div><hr><h3 id=方法四设置环境变量>方法四：设置环境变量</h3><p>在运行脚本前设置 <code>PYTHONPATH</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>PYTHONPATH</span><span class=o>=</span>/path/to/project_root python app/module1/script1.py
</span></span></code></pre></td></tr></table></div></div><p>或在代码中临时设置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s1>&#39;PYTHONPATH&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;/path/to/project_root&#39;</span>
</span></span></code></pre></td></tr></table></div></div><hr><h3 id=方法五通过包安装推荐大型项目>方法五：通过包安装（推荐大型项目）</h3><p>使用 <code>setup.py</code> 或 <code>pyproject.toml</code> 将项目安装为可编辑模式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># setup.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>setuptools</span> <span class=kn>import</span> <span class=n>setup</span><span class=p>,</span> <span class=n>find_packages</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>setup</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=o>=</span><span class=s1>&#39;my_project&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>version</span><span class=o>=</span><span class=s1>&#39;0.1&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>packages</span><span class=o>=</span><span class=n>find_packages</span><span class=p>(),</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>安装命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip install -e .
</span></span></code></pre></td></tr></table></div></div><p>安装后，可在任意位置导入：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>core_utils</span> <span class=kn>import</span> <span class=n>some_function</span>
</span></span></code></pre></td></tr></table></div></div><hr><h3 id=总结-7>总结</h3><ul><li><strong>小型项目</strong>：使用方法一或二动态添加路径。</li><li><strong>中大型项目</strong>：推荐方法三或五，通过包结构管理导入。</li><li><strong>灵活运行</strong>：方法四设置环境变量。</li></ul><p>根据项目需求选择最适合的方案。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2025-04-23</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://fjyu95.github.io/posts/python-7e260258c8264083a9e6e0b25feca29c/ data-title=Python data-hashtags=python><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://fjyu95.github.io/posts/python-7e260258c8264083a9e6e0b25feca29c/ data-hashtag=python><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://fjyu95.github.io/posts/python-7e260258c8264083a9e6e0b25feca29c/ data-title=Python><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://fjyu95.github.io/posts/python-7e260258c8264083a9e6e0b25feca29c/ data-title=Python><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://fjyu95.github.io/posts/python-7e260258c8264083a9e6e0b25feca29c/ data-title=Python><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/python/>Python</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/git-bash/ class=prev rel=prev title=Git><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Git</a>
<a href=/posts/online-toolkits-b6041ebb846649659d2145465714616c/ class=next rel=next title=在线实用工具>在线实用工具<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.145.0">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.3.0"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2020 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://fjyu95.github.io/ target=_blank>fjyu95</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>