<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>OpenCV - FangjieYu‘s site</title><meta name=Description content="This is my cool site"><meta property="og:url" content="https://fjyu95.github.io/posts/opencv-9d600a59535d4431919d0b76e8b198bf/">
<meta property="og:site_name" content="FangjieYu‘s site"><meta property="og:title" content="OpenCV"><meta property="og:description" content="安装
pip install opencv-python==3.4.2.16
pip install opencv-contrib-python==3.4.2.16
contrib版本提供了额外的扩展功能
Imread flags -1 unchanged
0 gray
1 color (default)
OpenCV: Flags used for image file reading and writing
https://docs.opencv.org/4.x/d8/d6a/group__imgcodecs__flags.html#gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822
imread/imwrite gray(bayer) -1,0 color -1,1,default cv2.imwrite（）不会自动创建未有的文件夹，并不会报错！"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-04T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-02T00:00:00+00:00"><meta property="article:tag" content="OpenCV"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenCV"><meta name=twitter:description content="安装
pip install opencv-python==3.4.2.16
pip install opencv-contrib-python==3.4.2.16
contrib版本提供了额外的扩展功能
Imread flags -1 unchanged
0 gray
1 color (default)
OpenCV: Flags used for image file reading and writing
https://docs.opencv.org/4.x/d8/d6a/group__imgcodecs__flags.html#gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822
imread/imwrite gray(bayer) -1,0 color -1,1,default cv2.imwrite（）不会自动创建未有的文件夹，并不会报错！"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://fjyu95.github.io/posts/opencv-9d600a59535d4431919d0b76e8b198bf/><link rel=prev href=https://fjyu95.github.io/posts/online-toolkits-b6041ebb846649659d2145465714616c/><link rel=next href=https://fjyu95.github.io/posts/hardware-5e47a1c2d08944afae871a05bef9d9bf/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"OpenCV","inLanguage":"en-us","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/fjyu95.github.io\/posts\/opencv-9d600a59535d4431919d0b76e8b198bf\/"},"genre":"posts","keywords":"OpenCV, python","wordcount":12627,"url":"https:\/\/fjyu95.github.io\/posts\/opencv-9d600a59535d4431919d0b76e8b198bf\/","datePublished":"2022-11-04T00:00:00+00:00","dateModified":"2024-12-02T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"fjyu95"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="FangjieYu‘s site">fjyu95</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>posts </a><a class=menu-item href=/tags/>tags </a><a class=menu-item href=/categories/>category </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="FangjieYu‘s site">fjyu95</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>posts</a><a class=menu-item href=/tags/ title>tags</a><a class=menu-item href=/categories/ title>category</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">OpenCV</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://fjyu95.github.io/ title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>fjyu95</a></span>&nbsp;<span class=post-category>included in <a href=/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/><i class="far fa-folder fa-fw" aria-hidden=true></i>图像处理</a>&nbsp;<a href=/categories/python/><i class="far fa-folder fa-fw" aria-hidden=true></i>Python</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-11-04>2022-11-04</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;12627 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;26 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#imread-flags>Imread flags</a></li><li><a href=#imreadimwrite>imread/imwrite</a></li><li><a href=#创建图像>创建图像</a></li><li><a href=#显示图像>显示图像</a></li><li><a href=#基础绘图>基础绘图</a></li><li><a href=#边缘检测>边缘检测</a></li><li><a href=#形状检测>形状检测</a></li><li><a href=#连通域提取>连通域提取</a></li><li><a href=#区域分割>区域分割</a></li><li><a href=#形态学处理>形态学处理</a></li><li><a href=#二值化>二值化</a></li><li><a href=#孔洞填充>孔洞填充</a></li><li><a href=#伪彩色映射>伪彩色映射</a></li><li><a href=#resize>resize</a></li><li><a href=#直方图>直方图</a></li><li><a href=#通道变换>通道变换</a></li><li><a href=#斑点检测>斑点检测</a></li><li><a href=#频率域处理>频率域处理</a></li><li><a href=#傅里叶变换>傅里叶变换</a></li><li><a href=#对图像进行二维傅里叶变换>对图像进行二维傅里叶变换</a></li><li><a href=#显示幅度谱>显示幅度谱</a></li><li><a href=#对频率域图像应用傅里叶逆变换>对频率域图像应用傅里叶逆变换</a></li><li><a href=#显示重建图像>显示重建图像</a></li><li><a href=#二维傅里叶变换的数学和物理解释>二维傅里叶变换的数学和物理解释</a><ul><li><ul><li><a href=#数学解释>数学解释</a></li><li><a href=#二维傅里叶变换的定义>二维傅里叶变换的定义</a></li><li><a href=#二维傅里叶逆变换>二维傅里叶逆变换</a></li><li><a href=#核心思想>核心思想</a></li><li><a href=#物理解释>物理解释</a></li><li><a href=#空间域与频率域>空间域与频率域</a></li><li><a href=#低频与高频>低频与高频</a></li><li><a href=#物理意义>物理意义</a></li><li><a href=#直观理解>直观理解</a></li><li><a href=#例子>例子</a></li><li><a href=#总结>总结</a></li></ul></li></ul></li><li><a href=#空间域和频率域与图像的对应关系>空间域和频率域与图像的对应关系</a><ul><li><ul><li><a href=#空间域>空间域</a></li><li><a href=#频率域>频率域</a></li><li><a href=#对应关系>对应关系</a></li><li><a href=#1-低频和高频成分>1. 低频和高频成分</a></li><li><a href=#2-空间域和频率域的转换>2. 空间域和频率域的转换</a></li><li><a href=#3-实例图像及其频率域表示>3. 实例图像及其频率域表示</a></li><li><a href=#理解图像中的频率>理解图像中的频率</a></li><li><a href=#结论>结论</a></li><li><a href=#幅度谱和相位谱><strong>幅度谱和相位谱</strong></a></li></ul></li></ul></li><li><a href=#零频的位置>零频的位置</a><ul><li><ul><li><a href=#零频的位置-1>零频的位置</a></li><li><a href=#数学解释-1>数学解释</a></li><li><a href=#二维傅里叶变换>二维傅里叶变换</a></li><li><a href=#零频位置>零频位置</a></li></ul></li></ul></li><li><a href=#创建一个示例图像>创建一个示例图像</a></li><li><a href=#进行二维傅里叶变换>进行二维傅里叶变换</a></li><li><a href=#使用-fftshift-将零频移到中心位置>使用 fftshift 将零频移到中心位置</a></li><li><a href=#显示原始图像默认频谱图和中心化后的频谱图>显示原始图像、默认频谱图和中心化后的频谱图</a></li><li><a href=#显示原始图像>显示原始图像</a></li><li><a href=#显示默认频谱图零频在左上角>显示默认频谱图（零频在左上角）</a></li><li><a href=#显示中心化后的频谱图零频在中心>显示中心化后的频谱图（零频在中心）</a></li><li><a href=#保存并显示图像>保存并显示图像</a></li><li><a href=#幅度谱和相位谱-1>幅度谱和相位谱</a><ul><li><ul><li><a href=#幅度谱和相位谱的定义>幅度谱和相位谱的定义</a></li><li><a href=#幅度谱magnitude-spectrum>幅度谱（Magnitude Spectrum）</a></li><li><a href=#相位谱phase-spectrum>相位谱（Phase Spectrum）</a></li><li><a href=#计算过程>计算过程</a></li><li><a href=#二维傅里叶变换-1>二维傅里叶变换</a></li><li><a href=#区别和联系>区别和联系</a></li><li><a href=#区别>区别</a></li><li><a href=#联系>联系</a></li><li><a href=#总结-1>总结</a></li></ul></li></ul></li><li><a href=#图像重建>图像重建</a><ul><li><ul><li><a href=#数学公式>数学公式</a></li><li><a href=#傅里叶变换和逆变换>傅里叶变换和逆变换</a></li><li><a href=#幅度谱和相位谱-2>幅度谱和相位谱</a></li><li><a href=#重建过程>重建过程</a></li><li><a href=#示例代码>示例代码</a></li><li><a href=#解释>解释</a></li><li><a href=#结果图像>结果图像</a></li><li><a href=#关键点>关键点</a></li><li><a href=#总结-2>总结</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><p>安装</p><p>pip install opencv-python==3.4.2.16</p><p>pip install opencv-contrib-python==3.4.2.16</p><p>contrib版本提供了额外的扩展功能</p><p><a href="https://blog.csdn.net/weixin_38673554/article/details/103639700#:~:text=%e6%8a%a5%e9%94%99%e5%8e%9f%e5%9b%a0%ef%bc%9a%e8%af%a5%e7%ae%97%e6%b3%95%e5%b7%b2%e7%bb%8f,OpenCV%e5%8e%bb%e6%8e%89%e4%ba%86%e8%bf%99%e4%b8%aa%e7%ae%97%e6%b3%95%e3%80%82" target=_blank rel="noopener noreffer"></a></p><h1 id=imread-flags>Imread flags</h1><p>-1 unchanged</p><p>0 gray</p><p>1 color (default)</p><p><a href=https://docs.opencv.org/4.x/d8/d6a/group__imgcodecs__flags.html#gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822 target=_blank rel="noopener noreffer">OpenCV: Flags used for image file reading and writing</a></p><p><a href=https://docs.opencv.org/4.x/d8/d6a/group__imgcodecs__flags.html#gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822 target=_blank rel="noopener noreffer">https://docs.opencv.org/4.x/d8/d6a/group__imgcodecs__flags.html#gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822</a></p><h1 id=imreadimwrite>imread/imwrite</h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>gray</span><span class=p>(</span><span class=n>bayer</span><span class=p>)</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>color</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=n>default</span>
</span></span></code></pre></div><p><strong>cv2.imwrite（）不会自动创建未有的文件夹，并不会报错！</strong></p><h1 id=创建图像>创建图像</h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>cv2</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建一个全黑图像（256x256，3 个通道）</span>
</span></span><span class=line><span class=cl><span class=n>black_image</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=mi>256</span><span class=p>,</span> <span class=mi>256</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>uint8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 OpenCV 显示图像</span>
</span></span><span class=line><span class=cl><span class=n>cv2</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=s1>&#39;Black Image&#39;</span><span class=p>,</span> <span class=n>black_image</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cv2</span><span class=o>.</span><span class=n>waitKey</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># 等待用户按下任意键关闭窗口</span>
</span></span><span class=line><span class=cl><span class=n>cv2</span><span class=o>.</span><span class=n>destroyAllWindows</span><span class=p>()</span>
</span></span></code></pre></div><h1 id=显示图像>显示图像</h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>matplotlib.pyplot</span> <span class=k>as</span> <span class=nn>plt</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>cv2</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>PIL</span> <span class=kn>import</span> <span class=n>Image</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 1、**matplotlib**</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>img</span><span class=p>[</span><span class=o>...</span><span class=p>,</span> <span class=p>::</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>  <span class=c1># RGB模式</span>
</span></span><span class=line><span class=cl><span class=c1># img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 将 BGR 转换为 RGB</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=s1>&#39;off&#39;</span><span class=p>)</span>  <span class=c1># 关闭坐标轴显示</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2、使用 OpenCV 显示图像</span>
</span></span><span class=line><span class=cl><span class=n>cv2</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=s1>&#39;Black Image&#39;</span><span class=p>,</span> <span class=n>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cv2</span><span class=o>.</span><span class=n>waitKey</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># 等待用户按下任意键关闭窗口</span>
</span></span><span class=line><span class=cl><span class=n>cv2</span><span class=o>.</span><span class=n>destroyAllWindows</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3、使用 PIL 显示图像</span>
</span></span><span class=line><span class=cl><span class=n>image</span> <span class=o>=</span> <span class=n>Image</span><span class=o>.</span><span class=n>fromarray</span><span class=p>(</span><span class=n>img</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>image</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</span></span></code></pre></div><ul><li><strong><code>matplotlib</code></strong>: 适合在交互式数据分析和可视化时使用，方便与其他图像和绘图结合。</li><li><strong><code>OpenCV</code></strong>: 强大的图像处理功能，适合计算机视觉任务。</li><li><strong><code>PIL (Pillow)</code></strong>: 简单轻量，适合图像转换和基本显示。</li></ul><h1 id=基础绘图>基础绘图</h1><p><a href=https://blog.csdn.net/u011520181/article/details/83933325 target=_blank rel="noopener noreffer">Python 用 OpenCV 画点和圆 (2)_python在图片上画点_星海流萤(AlanWang)的博客-CSDN博客</a></p><p>利用 opencv 里自带的 circle() 函数可以绘制以一个点为圆心特定半径的圆，其函数的声明如下：</p><p>cv2.circle(img, center, radius, color[, thickness[, lineType[, shift]]])<br>1<br>函数参数含义如下：</p><p>img：要画的圆所在的矩形或图像<br>center：圆心坐标，如 (100, 100)<br>radius：半径，如 10<br>color：圆边框颜色，如 (0, 0, 255) 红色，BGR<br>thickness：正值表示圆边框宽度. 负值表示画一个填充圆形<br>lineType：圆边框线型，可为 0，4，8<br>shift：圆心坐标和半径的小数点位数</p><h1 id=边缘检测>边缘检测</h1><p><a href=https://blog.csdn.net/wsp_1138886114/article/details/82935839 target=_blank rel="noopener noreffer">OpenCV—python 边缘检测（Canny）_SongpingWang的博客-CSDN博客</a></p><p><a href=https://zj-image-processing.readthedocs.io/zh-cn/latest/opencv/code/[Canny]%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b/#_4 target=_blank rel="noopener noreffer">[Canny]边缘检测 - image processing</a></p><p><code>canny = cv2.Canny(gray, 10, 30)</code> # 常用1:2 或 1:3</p><ul><li>低阈值固定，高阈值越高，细节越少</li><li>高阈值固定，低阈值越低，细节越多</li></ul><h1 id=形状检测>形状检测</h1><p><a href=https://blog.csdn.net/dcrmg/article/details/78880046 target=_blank rel="noopener noreffer">OpenCV-Python 霍夫直线检测-HoughLinesP函数参数_cv2.houghlinesp参数-CSDN博客</a></p><p><a href=https://blog.51cto.com/u_15362367/3888720 target=_blank rel="noopener noreffer">blog.51cto.com</a></p><h1 id=连通域提取>连通域提取</h1><p><a href=https://zhajiman.github.io/post/connected_component_labelling/#%e5%85%b6%e5%ae%83%e6%96%b9%e6%b3%95 target=_blank rel="noopener noreffer">二值图像的连通域标记</a></p><p><a href=https://blog.csdn.net/qq_30815237/article/details/86898686 target=_blank rel="noopener noreffer">OpenCV3学习（9.2）连通域分析函数详解connectedComponents()和connectedComponentsWithStats()_cv::connectedcomponents-CSDN博客</a></p><p>opencv使用起来更方便，返回值信息全面</p><h1 id=区域分割>区域分割</h1><p>前景物体分割是计算机视觉领域中的一个重要任务，旨在将图像中的前景对象与背景分离。以下是一些常见的前景物体分割算法：</p><ol><li><strong>基于阈值的分割</strong>：这是最简单的分割方法之一，通过设置合适的阈值将图像分成前景和背景。适用于前景对象与背景之间的对比度较高的情况。</li><li><strong>基于边缘检测的分割</strong>：通过检测图像中的边缘来找到前景对象的边界。常用的边缘检测算法包括 Canny 边缘检测、Sobel 算子等。</li><li><strong>基于区域的分割</strong>：将图像分成不同的区域，并根据区域之间的特征来判断哪些区域属于前景。常用的区域分割算法包括分水岭算法、区域增长算法等。</li><li><strong>基于深度学习的分割</strong>：使用深度学习方法来训练模型，从而实现对前景对象的准确分割。常用的深度学习模型包括 U-Net、Mask R-CNN 等。</li><li><strong>基于运动的分割</strong>：如果图像是视频序列，可以利用帧与帧之间的运动信息来进行前景分割。常用的方法包括基于光流的方法、基于背景建模的方法等。</li><li><strong>基于图割的分割</strong>：将图像分成多个区域，并通过最小割最大流算法来找到前景对象的边界。常用的图割算法包括 Boykov-Kolmogorov 算法等。grabcut 交互式前景分割 grabcut++</li><li><strong>基于轮廓的分割</strong>：通过检测图像中的轮廓来找到前景对象的边界。常用的轮廓检测算法包括基于边缘检测的方法、基于分水岭算法的方法等。</li></ol><p>这些算法可以单独使用，也可以结合使用，根据具体的图像特性和需求选择合适的方法。在实际应用中，通常需要根据具体情况来调整参数和算法，以获得最佳的分割效果。</p><h1 id=形态学处理>形态学处理</h1><p>不同形状的核在形态学操作中具有不同的影响和特点，因此在选择核时需要考虑图像的特点以及所需的操作效果。以下是不同核形状的选取规则和具体区别：</p><ol><li><strong>矩形核</strong>（cv2.MORPH_RECT）：<ul><li>特点：矩形核是最常用的形态学核之一，其在腐蚀和膨胀等操作中可以沿着水平和垂直方向分别对图像进行操作。</li><li>适用场景：适用于对图像中的细长结构进行处理，例如细小的噪声点或者细线条。</li></ul></li><li><strong>十字形核</strong>（cv2.MORPH_CROSS）：<ul><li>特点：十字形核与矩形核类似，但是它的中心像素为 1，周围的像素为 0，因此在一些情况下可以更强力地改变图像的结构。</li><li>适用场景：适用于对图像中的较粗线条或者边缘进行处理。</li></ul></li><li><strong>椭圆形核</strong>（cv2.MORPH_ELLIPSE）：<ul><li>特点：椭圆形核的特点是在腐蚀和膨胀操作中可以沿着任意方向改变图像的结构，因此可以更加灵活地适应图像的形状。</li><li>适用场景：适用于对图像中的圆形或者曲线结构进行处理，例如去除边缘或者弯曲部分的噪声。</li></ul></li></ol><p><a href=https://zhuanlan.zhihu.com/p/60770435 target=_blank rel="noopener noreffer">OpenCV图像处理-平滑处理、形态学操作</a></p><p><a href=https://blog.csdn.net/qq_53703628/article/details/119724968 target=_blank rel="noopener noreffer">OpenCV 理解腐蚀与膨胀(开、闭运算以及形态学方法)_opencv腐蚀膨胀__久夏青的博客-CSDN博客</a></p><p><img class=lazyload src=/svg/loading.min.svg data-src=OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled.png data-srcset="OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled.png, OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled.png 1.5x, OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled.png 2x" data-sizes=auto alt=OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled.png title=Untitled></p><h1 id=二值化>二值化</h1><p><a href=https://www.cnblogs.com/april0315/p/13576778.html target=_blank rel="noopener noreffer">python实现图像二值化 - 山那边不是山 - 博客园</a></p><p><a href=https://blog.csdn.net/ljx1400052550/article/details/114735364 target=_blank rel="noopener noreffer">Python图像的二值化_python二值化图像处理_ljx1400052550的博客-CSDN博客</a></p><p><a href=https://www.jianshu.com/p/d9f7bd20aa6d target=_blank rel="noopener noreffer">OpenCV+Python图像二值化</a></p><p><strong><code>cv2.adaptiveThreshold()</code></strong> 函数用于应用自适应阈值二值化。以下是该函数的参数列表及其说明：</p><ul><li><strong>src</strong>：输入图像，灰度图像（单通道图像）。</li><li><strong>maxValue</strong>：输出图像中的最大像素值。</li><li><strong>adaptiveMethod</strong>：自适应阈值算法的方法。可选参数为：<ul><li><strong><code>cv2.ADAPTIVE_THRESH_MEAN_C</code></strong>：基于邻域均值的阈值计算。</li><li><strong><code>cv2.ADAPTIVE_THRESH_GAUSSIAN_C</code></strong>：基于邻域加权平均的阈值计算。</li></ul></li><li><strong>thresholdType</strong>：阈值类型。可选参数为：<ul><li><strong><code>cv2.THRESH_BINARY</code></strong>：大于阈值的像素值设为 <strong><code>maxValue</code></strong>，小于等于阈值的像素值设为 0。</li><li><strong><code>cv2.THRESH_BINARY_INV</code></strong>：大于阈值的像素值设为 0，小于等于阈值的像素值设为 <strong><code>maxValue</code></strong>。</li></ul></li><li><strong>blockSize</strong>：局部区域的大小，用于计算阈值。它应该是一个奇数，例如 3、5、7、9 等。</li><li><strong>C</strong>：从局部块中减去的常数。它是一个可选参数，通常为正数或零。</li></ul><p>以下是函数的调用格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>pythonCopy</span> <span class=n>code</span>
</span></span><span class=line><span class=cl><span class=n>retval</span><span class=p>,</span> <span class=n>dst</span> <span class=o>=</span> <span class=n>cv2</span><span class=o>.</span><span class=n>adaptiveThreshold</span><span class=p>(</span><span class=n>src</span><span class=p>,</span> <span class=n>maxValue</span><span class=p>,</span> <span class=n>adaptiveMethod</span><span class=p>,</span> <span class=n>thresholdType</span><span class=p>,</span> <span class=n>blockSize</span><span class=p>,</span> <span class=n>C</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>retval</strong>：返回的阈值。</li><li><strong>dst</strong>：输出的二值化图像。</li></ul><h1 id=孔洞填充>孔洞填充</h1><p>1、cv2.floodFill</p><p>2、findContours + fillPoly</p><p><em>3、形态学重建，连续进行膨胀操作</em></p><p><a href=https://blog.csdn.net/weixin_43610114/article/details/128034901 target=_blank rel="noopener noreffer">OpenCV函数应用：基于二值图像的三种孔洞填充方法记录（附python，C++代码）_opencv填充孔洞-CSDN博客</a></p><p><a href=https://www.jb51.net/article/215268.htm target=_blank rel="noopener noreffer"></a></p><p><img class=lazyload src=/svg/loading.min.svg data-src=OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled%201.png data-srcset="OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled%201.png, OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled%201.png 1.5x, OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled%201.png 2x" data-sizes=auto alt=OpenCV%209d600a59535d4431919d0b76e8b198bf/Untitled%201.png title=Untitled></p><p><strong>自动选中与种子像素相连的区域，并赋予指定颜色值</strong></p><p><a href="https://lh3.googleusercontent.com/a/ACg8ocLa8Ss4WzDaU2utfpleawZuEAFRWbWEtmp8vOTT5pAwQA=s96-c" target=_blank rel="noopener noreffer"></a></p><p>opencv 漫水填充算法原理</p><p>ChatGPT</p><p>OpenCV 中的漫水填充算法（Flood Fill Algorithm）是一种基于种子点的区域填充算法，用于填充图像中的连通区域。它从指定的种子点开始，搜索与种子点相邻且具有相似像素值的区域，并将这些像素填充为指定的颜色。</p><p>漫水填充算法的原理如下：</p><ol><li><strong>选择种子点：</strong> 首先需要选择一个种子点，这个点是填充操作的起始点。</li><li><strong>像素匹配：</strong> 从种子点开始，检查当前像素的相邻像素。如果相邻像素的像素值在指定的阈值范围内（可以是灰度值的差异或颜色空间中的差异），则将其标记为填充目标，并继续对其相邻像素进行检查。</li><li><strong>填充：</strong> 对于每个相邻像素，如果它的像素值符合条件，则将其标记为填充目标，并继续搜索其相邻像素。这个过程将一直进行下去，直到无法再填充新的像素为止。</li><li><strong>停止条件：</strong> 填充操作会在遇到边界或无法满足条件的像素时停止。</li><li><strong>重复填充：</strong> 漫水填充算法可以选择性地进行重复填充，以填充多个相邻区域。</li></ol><p>在 OpenCV 中，<code>cv2.floodFill()</code> 函数实现了漫水填充算法。该函数接受输入图像、种子点、填充颜色等参数，并根据指定的条件填充图像。通过调整函数的参数，可以实现不同的填充效果，如填充区域的颜色、填充的像素范围等。</p><p>如果要使用漫水填充算法填充图像中的多个孔洞，您可以通过重复调用 <code>cv2.floodFill()</code> 函数来实现。每次调用函数时，都需要选择一个不同的种子点，并确保选择的种子点位于不同的孔洞内部。以下是一个示例代码，演示如何使用漫水填充算法填充图像中的多个孔洞：</p><h1 id=伪彩色映射>伪彩色映射</h1><p><a href=https://www.cnblogs.com/zzzsj/p/14485715.html target=_blank rel="noopener noreffer">OpenCV &ndash; 归一化函数normalize() - 手磨咖啡 - 博客园</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 拉伸灰度范围</span>
</span></span><span class=line><span class=cl><span class=n>normalized_image</span> <span class=o>=</span> <span class=n>cv2</span><span class=o>.</span><span class=n>normalize</span><span class=p>(</span><span class=n>gray_image</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>255</span><span class=p>,</span> <span class=n>cv2</span><span class=o>.</span><span class=n>NORM_MINMAX</span><span class=p>)</span>
</span></span></code></pre></div><p><a href=https://www.cnblogs.com/Anita9002/p/9076112.html target=_blank rel="noopener noreffer">opencv中图像伪彩色处理（C++ / Python） - Anita-ff - 博客园</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kr>import</span> <span class=nx>cv2</span> 
</span></span><span class=line><span class=cl><span class=nx>im_gray</span> <span class=o>=</span> <span class=nx>cv2</span><span class=p>.</span><span class=nx>imread</span><span class=p>(</span><span class=s2>&#34;pluto.jpg&#34;</span><span class=p>,</span> <span class=nx>cv2</span><span class=p>.</span><span class=nx>IMREAD_GRAYSCALE</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=nx>im_color</span> <span class=o>=</span> <span class=nx>cv2</span><span class=p>.</span><span class=nx>applyColorMap</span><span class=p>(</span><span class=nx>im_gray</span><span class=p>,</span> <span class=nx>cv2</span><span class=p>.</span><span class=nx>COLORMAP_JET</span><span class=p>)</span>
</span></span></code></pre></div><h1 id=resize>resize</h1><p><a href=https://www.cnblogs.com/bjxqmy/p/12316843.html target=_blank rel="noopener noreffer">opencv —— resize、pyrUp 和 pyrDown 图像金字塔（高斯金字塔、拉普拉斯金字塔）与尺寸缩放（向上采样、向下采样） - 狂奔的小学生 - 博客园</a></p><p><strong>尺寸调整：resize 函数</strong></p><p>此函数将源图像精确地转换为指定尺寸地目标图像。如果源图像中设置了 ROI（感兴趣区域），那么 resize() 函数就会对源图像地 ROI 区域进行调整尺寸操作，来输出到目标图像中。若目标图像中已经设置了 ROI 区域，不难理解 resize() 函数将会对源图像进行尺寸调整并填充到目标图像的 ROI 区域中去。</p><blockquote><p>void resize(InputArray src, OutputArray dst, Size dsize, double fx = 0, double fy = 0, int interpolation = INTER_LINEAR);</p></blockquote><ul><li>src，输入图像，Mat 类对象即可。</li><li>dst，输出图像，若其非零时，有着 dsize 的尺寸，或者由 src.size() 计算出来。</li><li>dsize，输出图像的尺寸。如果它等于零，由如下公式进行计算：</li></ul><p><strong>dsize = Size ( round ( fx * src.cols ), round( fy * src.rows ) );</strong></p><ul><li>fx，延水平轴的缩放系数，有默认值 0，且为 0 时，由下式进行计算：</li></ul><p><strong>fx = (double) dsize.width / src.cols</strong></p><ul><li>fy，延垂直轴的缩放系数，有默认值 0，为 0 时，由下式进行计算：</li></ul><p><strong>fy = (double) dsize.height / src.rows</strong></p><ul><li>interpolation，指定插值方式，默认为 INTER_LINEAR （线性插值）。插值就是根据已知数据点（条件），来预测未知数据点值得方法。在尺寸调整过程中，图像的大小可能发生改变。此时像素与像素之间的关系就不是一一对应关系，因此在尺寸调整过程中，可能会涉及到像素值的插值计算。可选插值方式如下：<ul><li>INTER_NEAREST（最近邻差值）</li><li>INTER_LINEAR（线性插值，默认）</li><li>INTER_AREA（区域插值，利用像素区域关系的重采样插值）</li><li>INTER_CUBIC（三次样条插值，超过 4×4 像素邻域内的双三次插值）</li><li>INTER_LANCZOS4（Lanczos 插值，超过 8×8 像素邻域的 Lanczos 插值）</li></ul></li></ul><p>若要缩小图像，一般情况下最好用 INTER_AREA 来插值；若要放大图像，一般情况下用 INTER_LINEAR。</p><p><a href=https://www.cnblogs.com/bjxqmy/p/12316843.html target=_blank rel="noopener noreffer">opencv —— resize、pyrUp 和 pyrDown 图像金字塔（高斯金字塔、拉普拉斯金字塔）与尺寸缩放（向上采样、向下采样） - 狂奔的小学生 - 博客园</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>resized_image</span> <span class=o>=</span> <span class=n>cv2</span><span class=o>.</span><span class=n>resize</span><span class=p>(</span><span class=n>src</span><span class=p>,</span> <span class=n>dsize</span><span class=p>[,</span> <span class=n>dst</span><span class=p>[,</span> <span class=n>fx</span><span class=p>[,</span> <span class=n>fy</span><span class=p>[,</span> <span class=n>interpolation</span><span class=p>]]]])</span>
</span></span><span class=line><span class=cl><span class=n>cv2</span><span class=o>.</span><span class=n>resize</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>h</span><span class=p>)</span> <span class=c1># 指定大小</span>
</span></span><span class=line><span class=cl><span class=n>cv2</span><span class=o>.</span><span class=n>resize</span><span class=p>(</span><span class=n>gray</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=n>fx</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>fy</span><span class=o>=</span><span class=mf>0.1</span><span class=p>)</span> <span class=c1># 指定缩放比例</span>
</span></span><span class=line><span class=cl><span class=n>cv2</span><span class=o>.</span><span class=n>resize</span><span class=p>(</span><span class=n>base_img</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=n>fx</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=n>fy</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=n>interpolation</span><span class=o>=</span><span class=n>cv2</span><span class=o>.</span><span class=n>INTER_CUBIC</span><span class=p>)</span> <span class=c1># 指定插值方法</span>
</span></span></code></pre></div><p>其中：</p><ul><li><code>src</code>：输入图像。</li><li><code>dsize</code>：输出图像的大小，可以是一个元组 <code>(width, height)</code>，也可以是一个缩放比例的元组 <code>(fx, fy)</code>，在这种情况下，输出图像的大小将按照输入图像的大小乘以缩放比例来计算。</li><li><code>dst</code>：输出图像，可选参数。</li><li><code>fx</code>：水平方向的缩放比例，可选参数。</li><li><code>fy</code>：垂直方向的缩放比例，可选参数。</li><li><code>interpolation</code>：插值方法，用于调整图像大小。可以是以下值之一：<ul><li><code>cv2.INTER_NEAREST</code>：最近邻插值。</li><li><code>cv2.INTER_LINEAR</code>：双线性插值（默认值）。</li><li><code>cv2.INTER_AREA</code>：区域插值。</li><li><code>cv2.INTER_CUBIC</code>：双立方插值。</li><li><code>cv2.INTER_LANCZOS4</code>：Lanczos插值。</li></ul></li></ul><h1 id=直方图>直方图</h1><p><a href=https://mdnice.com/writing/818a5cfbd6c34980bacc1091cb5add5f target=_blank rel="noopener noreffer">墨滴社区</a></p><h1 id=通道变换>通道变换</h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>img</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>expand_dims</span><span class=p>(</span><span class=n>gray</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>repeat</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 单通道转三通道</span>
</span></span><span class=line><span class=cl><span class=n>img</span> <span class=o>=</span> <span class=n>cv2</span><span class=o>.</span><span class=n>cvtColor</span><span class=p>(</span><span class=n>gray</span><span class=p>,</span> <span class=n>cv2</span><span class=o>.</span><span class=n>COLOR_GRAY2BGR</span><span class=p>)</span> 
</span></span></code></pre></div><h1 id=斑点检测>斑点检测</h1><p><a href=https://blog.csdn.net/u014072827/article/details/111033547 target=_blank rel="noopener noreffer"></a></p><p><a href=https://www.jianshu.com/p/900669adbb28 target=_blank rel="noopener noreffer"></a></p><h1 id=频率域处理>频率域处理</h1><p>空间域和频率域的转换</p><p>图像在空间域和频率域之间的转换通过傅里叶变换和逆傅里叶变换实现。具体步骤如下：</p><pre tabindex=0><code>傅里叶变换：将空间域图像转换为频率域表示。二维傅里叶变换用于图像处理：
F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(uxM+vyN)
F(u,v)=x=0∑M−1y=0∑N−1f(x,y)⋅e−j2π(Mux+Nvy)

其中，f(x,y)f(x,y) 是空间域图像，F(u,v)F(u,v) 是频率域表示，MM 和 NN 分别是图像的宽度和高度。

逆傅里叶变换：将频率域图像转换回空间域表示：
f(x,y)=1MN∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(uxM+vyN)
f(x,y)=MN1u=0∑M−1v=0∑N−1F(u,v)⋅ej2π(Mux+Nvy)
</code></pre><p>典型应用</p><pre tabindex=0><code>图像去噪：频率域的低通滤波可以去除高频噪声，空间域的中值滤波可以去除椒盐噪声。
图像锐化：频率域的高通滤波可以增强图像边缘，空间域的拉普拉斯滤波也可以达到类似效果。
图像压缩：JPEG压缩通过离散余弦变换（DCT）将图像转换到频率域，保留主要的低频成分进行压缩。
</code></pre><h1 id=傅里叶变换>傅里叶变换</h1><p>二维傅里叶变换（2D Fourier Transform）是将图像从空间域转换到频率域的一个重要工具。它的计算过程包括傅里叶变换和傅里叶逆变换的数学表示。以下是详细的数学解释：<br>二维傅里叶变换的数学定义</p><p>对于一个二维离散图像 f(x,y)f(x,y)，其傅里叶变换 F(u,v)F(u,v) 定义如下：<br>F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(uxM+vyN)F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(Mux+Nvy)</p><p>其中：</p><pre tabindex=0><code>f(x,y)f(x,y) 是空间域中的图像，xx 和 yy 分别是图像的行和列坐标。
F(u,v)F(u,v) 是频率域中的图像，uu 和 vv 分别是频率坐标。
MM 和 NN 分别是图像的宽度和高度。
jj 是虚数单位。
</code></pre><p>傅里叶逆变换的数学定义</p><p>傅里叶逆变换将频率域中的图像转换回空间域，其定义如下：<br>f(x,y)=1MN∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(uxM+vyN)f(x,y)=MN1∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(Mux+Nvy)</p><p>其中：</p><pre tabindex=0><code>f(x,y)f(x,y) 是重建的空间域图像。
F(u,v)F(u,v) 是频率域中的图像。
</code></pre><p>计算过程的详细解释</p><ol><li>创建示例图像</li></ol><p>首先，我们创建一个简单的示例图像，带有水平梯度和噪声。<br>2. 进行二维傅里叶变换</p><p>使用傅里叶变换公式：<br>F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(uxM+vyN)F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(Mux+Nvy)</p><p>这一步将图像从空间域转换到频率域。在实际计算中，我们使用快速傅里叶变换（FFT）算法来提高计算效率。下面是用Python实现的步骤：</p><p>python</p><p>from scipy.fft import fft2, fftshift</p><h1 id=对图像进行二维傅里叶变换>对图像进行二维傅里叶变换</h1><p>f_transform = fft2(image_with_noise)<br>f_transform_shifted = fftshift(f_transform) # 将零频移到中心<br>magnitude_spectrum = np.log(np.abs(f_transform_shifted) + 1)</p><h1 id=显示幅度谱>显示幅度谱</h1><p>plt.imshow(magnitude_spectrum, cmap=&lsquo;gray&rsquo;)<br>plt.title(&lsquo;幅度谱（频率域）&rsquo;)<br>plt.axis(&lsquo;off&rsquo;)<br>plt.show()</p><ol><li>进行傅里叶逆变换</li></ol><p>使用傅里叶逆变换公式：<br>f(x,y)=1MN∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(uxM+vyN)f(x,y)=MN1∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(Mux+Nvy)</p><p>这一步将图像从频率域转换回空间域。在实际计算中，我们使用快速傅里叶逆变换（IFFT）算法。下面是用Python实现的步骤：</p><p>python</p><p>from scipy.fft import ifft2, ifftshift</p><h1 id=对频率域图像应用傅里叶逆变换>对频率域图像应用傅里叶逆变换</h1><p>f_ishift = ifftshift(f_transform_shifted) # 将零频移回原位<br>img_reconstructed = ifft2(f_ishift)<br>img_reconstructed = np.abs(img_reconstructed)</p><h1 id=显示重建图像>显示重建图像</h1><p>plt.imshow(img_reconstructed, cmap=&lsquo;gray&rsquo;)<br>plt.title(&lsquo;重建图像（傅里叶逆变换）&rsquo;)<br>plt.axis(&lsquo;off&rsquo;)<br>plt.show()</p><p>直观理解</p><pre tabindex=0><code>二维傅里叶变换：将图像的空间域信息转换为频率域信息。图像的每个像素值被表示为一组正弦和余弦波的叠加，其频率和相位表示图像中的空间频率成分。
傅里叶逆变换：将频率域信息重新组合，转换回空间域。这一步验证了频率域表示的正确性和完整性。
</code></pre><p>通过傅里叶变换和傅里叶逆变换，我们可以在不同的域之间切换，利用频率域的信息进行各种图像处理操作，如去噪、增强和压缩等。这些数学公式和计算过程为图像处理提供了强大的理论基础和工具。</p><h1 id=二维傅里叶变换的数学和物理解释>二维傅里叶变换的数学和物理解释</h1><p>二维傅里叶变换是一种将二维信号（例如图像）从空间域转换到频率域的变换。它在图像处理中具有重要意义，因为它能够将图像的空间信息分解为不同的频率成分。下面我们从数学和物理的角度详细解释这一过程。</p><h3 id=数学解释>数学解释</h3><h3 id=二维傅里叶变换的定义>二维傅里叶变换的定义</h3><p>二维傅里叶变换（2D Fourier Transform）将一个二维离散信号 f(x,y)f(x, y)f(x,y) 从空间域转换到频率域，其定义如下：</p><p>F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(uxM+vyN)F(u, v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) \cdot e^{-j2\pi\left(\frac{ux}{M} + \frac{vy}{N}\right)}F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(Mux+Nvy)</p><p>其中：</p><ul><li><p>f(x,y)f(x, y)f(x,y) 是空间域的图像，表示在位置 (x,y) 的像素值。</p><p>(x,y)(x, y)</p></li><li><p>F(u,v)F(u, v)F(u,v) 是频率域的图像，表示频率 (u,v) 处的频率成分。</p><p>(u,v)(u, v)</p></li><li><p>MMM 和 N 分别是图像的宽度和高度。</p><p>NN</p></li><li><p>jjj 是虚数单位，满足 j2=−1。</p><p>j2=−1j^2 = -1</p></li></ul><h3 id=二维傅里叶逆变换>二维傅里叶逆变换</h3><p>二维傅里叶逆变换将频率域的图像转换回空间域，其定义如下：</p><p>f(x,y)=1MN∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(uxM+vyN)f(x, y) = \frac{1}{MN} \sum_{u=0}^{M-1} \sum_{v=0}^{N-1} F(u, v) \cdot e^{j2\pi\left(\frac{ux}{M} + \frac{vy}{N}\right)}f(x,y)=MN1∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(Mux+Nvy)</p><h3 id=核心思想>核心思想</h3><p>傅里叶变换的核心思想是将图像视为许多正弦波的叠加。每个正弦波具有不同的频率和相位，傅里叶变换计算出这些正弦波的幅度和相位，从而表示图像的频率成分。</p><h3 id=物理解释>物理解释</h3><h3 id=空间域与频率域>空间域与频率域</h3><ul><li><strong>空间域</strong>：在空间域中，图像是由像素组成的矩阵，每个像素值表示该位置的灰度或颜色值。空间域描述了图像的直接视觉内容。</li><li><strong>频率域</strong>：在频率域中，图像被分解为不同的频率成分，表示图像中像素值变化的速率。频率域描述了图像的结构特征，如边缘和纹理。</li></ul><h3 id=低频与高频>低频与高频</h3><ul><li><strong>低频成分</strong>：代表图像中的大面积平滑区域，变化缓慢。低频成分在频谱的中心区域，包含了图像的整体轮廓和主要特征。</li><li><strong>高频成分</strong>：代表图像中的细节和边缘，变化迅速。高频成分在频谱的外围区域，包含了图像的细节和噪声。</li></ul><h3 id=物理意义>物理意义</h3><p>傅里叶变换在物理上对应于将图像从空间域转换到频率域的过程，这类似于将一个复杂的波形分解为许多简单的正弦波。每个正弦波的频率、幅度和相位共同描述了图像的一个频率成分。</p><h3 id=直观理解>直观理解</h3><ol><li><strong>图像中的频率</strong>：图像中的频率表示像素值变化的速率。高频表示像素值快速变化（如边缘和细节），低频表示像素值缓慢变化（如平坦区域和背景）。</li><li><strong>傅里叶变换过程</strong>：<ul><li><strong>输入</strong>：一个二维图像，表示为像素值矩阵。</li><li><strong>处理</strong>：傅里叶变换将图像中每个像素值与一组正弦波相乘并求和，计算出每个频率成分的幅度和相位。</li><li><strong>输出</strong>：频率域图像，显示每个频率成分的强度（幅度谱）。</li></ul></li><li><strong>频率域图像</strong>：<ul><li><strong>中心区域</strong>：表示低频成分，描述图像的整体轮廓和主要结构。</li><li><strong>外围区域</strong>：表示高频成分，描述图像的细节和噪声。</li></ul></li></ol><h3 id=例子>例子</h3><p>假设我们有一个简单的二维图像，图像中有一个垂直的黑色条纹。当我们对这个图像进行二维傅里叶变换时，我们会得到一个频率域图像，其中水平中间的频率成分较强，表示图像中存在垂直方向的频率成分。</p><h3 id=总结>总结</h3><p>二维傅里叶变换将图像从空间域转换到频率域，使我们能够分析和处理图像中的频率成分。通过傅里叶变换，我们可以了解图像的结构特征，进行去噪、增强和压缩等处理。傅里叶变换的数学定义和物理意义为图像处理提供了强大的工具和理论基础。</p><h1 id=空间域和频率域与图像的对应关系>空间域和频率域与图像的对应关系</h1><p>图像处理中的空间域和频率域提供了两种不同的视角来分析和处理图像。以下是这两个域与图像的对应关系及其具体理解。</p><h3 id=空间域>空间域</h3><p><strong>定义</strong>：空间域是指图像本身的像素值分布，它直接描述了图像的视觉内容。</p><p><strong>表示方法</strong>：</p><ul><li><p>图像在空间域中表示为一个二维矩阵，每个元素表示一个像素的灰度值或颜色值。</p></li><li><p>例如，灰度图像可以表示为 f(x,y)，其中 x 和 y 是像素坐标，f(x,y) 是在 (x,y) 处的灰度值。</p><p>f(x,y)f(x, y)</p><p>xx</p><p>yy</p><p>f(x,y)f(x, y)</p><p>(x,y)(x, y)</p></li></ul><p><strong>操作</strong>：</p><ul><li><strong>平滑滤波</strong>：如均值滤波、中值滤波，用于去除噪声。</li><li><strong>边缘检测</strong>：如Sobel滤波、Canny边缘检测，用于检测图像中的边缘。</li><li><strong>锐化</strong>：如拉普拉斯滤波，用于增强图像中的细节。</li></ul><p><strong>图像特征</strong>：</p><ul><li><strong>大面积均匀区域</strong>：像素值变化缓慢，通常表示图像中的背景或大块颜色区域。</li><li><strong>细节和边缘</strong>：像素值变化迅速，表示图像中的细节部分，如边缘和纹理。</li></ul><h3 id=频率域>频率域</h3><p><strong>定义</strong>：频率域是指<strong>图像的频率成分分布，它描述了图像中像素值变化的速率</strong>。</p><p><strong>表示方法</strong>：</p><ul><li><p>图像在频率域中表示为一个二维频谱矩阵，通过二维傅里叶变换从空间域转换而来。</p></li><li><p>例如，频率域图像可以表示为 F(u,v)，其中 u 和 v 是频率坐标，F(u,v) 是在 (u,v) 处的频率成分。</p><p>F(u,v)F(u, v)</p><p>uu</p><p>vv</p><p>F(u,v)F(u, v)</p><p>(u,v)(u, v)</p></li></ul><p><strong>操作</strong>：</p><ul><li><strong>低通滤波</strong>：去除高频成分，用于图像平滑和去噪。</li><li><strong>高通滤波</strong>：去除低频成分，用于图像锐化和边缘增强。</li><li><strong>带通滤波</strong>：保留特定频率范围内的成分，用于纹理分析。</li></ul><p><strong>图像特征</strong>：</p><ul><li><strong>低频成分</strong>：表示图像中大面积均匀区域的变化，通常在频谱图的中心。</li><li><strong>高频成分</strong>：表示图像中的细节和边缘，通常在频谱图的外围。</li></ul><h3 id=对应关系>对应关系</h3><h3 id=1-低频和高频成分>1. 低频和高频成分</h3><ul><li><strong>低频成分</strong>：图像中的大面积平滑区域在频率域中表现为低频成分。这些成分位于频谱图的中心，表示变化缓慢的部分。</li><li><strong>高频成分</strong>：图像中的细节和边缘在频率域中表现为高频成分。这些成分位于频谱图的外围，表示变化迅速的部分。</li></ul><h3 id=2-空间域和频率域的转换>2. 空间域和频率域的转换</h3><ul><li><p><strong>傅里叶变换</strong>：将图像从空间域转换到频率域，表示为：<br>F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(Mux+Nvy)<br>其中，f(x,y) 是空间域图像，F(u,v) 是频率域图像。</p><p>F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(uxM+vyN)F(u, v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) \cdot e^{-j2\pi\left(\frac{ux}{M} + \frac{vy}{N}\right)}</p><p>f(x,y)f(x, y)</p><p>F(u,v)F(u, v)</p></li><li><p><strong>傅里叶逆变换</strong>：将图像从频率域转换回空间域，表示为：<br>f(x,y)=MN1∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(Mux+Nvy)</p><p>f(x,y)=1MN∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(uxM+vyN)f(x, y) = \frac{1}{MN} \sum_{u=0}^{M-1} \sum_{v=0}^{N-1} F(u, v) \cdot e^{j2\pi\left(\frac{ux}{M} + \frac{vy}{N}\right)}</p></li></ul><h3 id=3-实例图像及其频率域表示>3. 实例图像及其频率域表示</h3><ul><li><strong>原始图像（空间域）</strong>：</li><li><strong>频率域表示（幅度谱）</strong>：</li></ul><h3 id=理解图像中的频率>理解图像中的频率</h3><ul><li><strong>低频区域</strong>：频率域图像中心区域，表示图像中平滑变化的大面积区域。</li><li><strong>高频区域</strong>：频率域图像外围区域，表示图像中的细节和边缘。</li><li><strong>频谱图</strong>：通过傅里叶变换得到的频谱图直观地显示了图像的频率成分，中心亮表示低频成分强，外围亮表示高频成分强。</li></ul><h3 id=结论>结论</h3><p><strong>空间域和频率域提供了两种不同的视角来分析和处理图像。空间域直接反映了图像的视觉内容，而频率域则揭示了图像中的频率成分及其分布</strong>。通过傅里叶变换和逆变换，我们可以在这两个域之间进行转换，利用频率域的信息来进行图像的去噪、增强、压缩等处理。理解这两个域的对应关系，有助于我们更有效地处理和分析图像。</p><h3 id=幅度谱和相位谱><strong>幅度谱和相位谱</strong></h3><ul><li><strong>幅度谱（Magnitude Spectrum）：表示频率成分的强度，具有中心对称性，即：<br>∣F(u,v)∣=∣F(−u,−v)∣|F(u, v)| = |F(-u, -v)|∣F(u,v)∣=∣F(−u,−v)∣</strong></li><li><strong>相位谱（Phase Spectrum）：表示频率成分的相位变化，具有反对称性，即：<br>∠F(u,v)=−∠F(−u,−v)\angle F(u, v) = -\angle F(-u, -v)∠F(u,v)=−∠F(−u,−v)</strong></li></ul><h1 id=零频的位置>零频的位置</h1><p>在频率域中，零频（zero frequency）的确切位置取决于你如何处理傅里叶变换的输出。让我们详细解释一下这个问题，并明确零频的位置。</p><h3 id=零频的位置-1>零频的位置</h3><ol><li><strong>傅里叶变换的输出</strong>：<ul><li>当你对图像进行二维傅里叶变换时，使用 <code>fft2</code> 函数，零频成分默认位于左上角，即图像的原点位置 (0, 0)。</li></ul></li><li><strong>傅里叶变换后的频谱</strong>：<ul><li>直接使用 <code>fft2</code> 得到的频谱图中，零频位于左上角。这对于很多应用来说并不直观，因为我们通常希望零频位于频谱图的中心，以更方便地分析和处理图像的频率成分。</li></ul></li><li><strong>频谱图的中心化</strong>：<ul><li>为了将零频移到频谱图的中心，我们使用 <code>fftshift</code> 函数。<code>fftshift</code> 将频谱图进行重新排列，使零频位于图像的中心位置。这种中心化的频谱图更直观，常用于频域滤波和其他图像处理操作。</li></ul></li></ol><h3 id=数学解释-1>数学解释</h3><h3 id=二维傅里叶变换>二维傅里叶变换</h3><p>对于一个 M×NM \times NM×N 的图像 f(x,y)f(x, y)f(x,y)，其二维傅里叶变换 F(u,v)F(u, v)F(u,v) 定义为：<br>F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(uxM+vyN)F(u, v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) \cdot e^{-j2\pi\left(\frac{ux}{M} + \frac{vy}{N}\right)}F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(Mux+Nvy)</p><h3 id=零频位置>零频位置</h3><ul><li><p><strong>默认位置</strong>：使用 <code>fft2</code> 进行傅里叶变换后，零频位置在左上角 (0,0)。</p><p>(0,0)(0, 0)</p></li><li><p><strong>中心化位置</strong>：使用 <code>fftshift</code> 后，零频位置移动到中心 (2M,2N)。</p><p>(M2,N2)\left(\frac{M}{2}, \frac{N}{2}\right)</p></li></ul><p>实际示例</p><p>以下代码演示了如何对图像进行傅里叶变换，并使用 fftshift 将零频移到中心位置：</p><p>python</p><p>import numpy as np<br>import matplotlib.pyplot as plt<br>from scipy.fft import fft2, fftshift</p><h1 id=创建一个示例图像>创建一个示例图像</h1><p>image_size = 256<br>image = np.tile(np.linspace(0, 1, image_size), (image_size, 1))</p><h1 id=进行二维傅里叶变换>进行二维傅里叶变换</h1><p>f_transform = fft2(image)<br>magnitude_spectrum_default = np.log(np.abs(f_transform) + 1)</p><h1 id=使用-fftshift-将零频移到中心位置>使用 fftshift 将零频移到中心位置</h1><p>f_transform_shifted = fftshift(f_transform)<br>magnitude_spectrum_shifted = np.log(np.abs(f_transform_shifted) + 1)</p><h1 id=显示原始图像默认频谱图和中心化后的频谱图>显示原始图像、默认频谱图和中心化后的频谱图</h1><p>fig, ax = plt.subplots(1, 3, figsize=(18, 6))</p><h1 id=显示原始图像>显示原始图像</h1><p>ax[0].imshow(image, cmap=&lsquo;gray&rsquo;)<br>ax[0].set_title(&lsquo;原始图像&rsquo;)<br>ax[0].axis(&lsquo;off&rsquo;)</p><h1 id=显示默认频谱图零频在左上角>显示默认频谱图（零频在左上角）</h1><p>ax[1].imshow(magnitude_spectrum_default, cmap=&lsquo;gray&rsquo;)<br>ax[1].set_title(&lsquo;默认频谱图（零频在左上角）&rsquo;)<br>ax[1].axis(&lsquo;off&rsquo;)</p><h1 id=显示中心化后的频谱图零频在中心>显示中心化后的频谱图（零频在中心）</h1><p>ax[2].imshow(magnitude_spectrum_shifted, cmap=&lsquo;gray&rsquo;)<br>ax[2].set_title(&lsquo;中心化频谱图（零频在中心）&rsquo;)<br>ax[2].axis(&lsquo;off&rsquo;)</p><h1 id=保存并显示图像>保存并显示图像</h1><p>plt.tight_layout()<br>plt.savefig("/mnt/data/frequency_domain_center_shift.png")<br>plt.show()</p><p>结果图像</p><pre tabindex=0><code>原始图像：显示一个水平梯度的示例图像。
默认频谱图：零频位于左上角。
中心化频谱图：使用 fftshift 后，零频位于中心。
</code></pre><p>解释</p><pre tabindex=0><code>默认频谱图：傅里叶变换后零频位于左上角，这是因为傅里叶变换计算的频率成分按顺序排列，最低频率在开始位置。
中心化频谱图：通过 fftshift 函数将频谱重新排列，使零频位于中心，这样可以更直观地观察和处理频率成分。
</code></pre><p>总结</p><pre tabindex=0><code>默认位置：傅里叶变换后，零频位于左上角。
中心化位置：使用 fftshift 函数后，零频移到频谱图的中心位置。
</code></pre><p>理解频率域中零频的位置对于频域分析和处理非常重要，通过中心化频谱图，我们可以更清楚地看到图像的频率分布特性，从而进行有效的图像处理操作。</p><h1 id=幅度谱和相位谱-1>幅度谱和相位谱</h1><p>在图像傅里叶变换中，幅度谱和相位谱是频率域表示的两个重要组成部分。理解它们的区别和联系对于图像处理和分析非常重要。以下是幅度谱和相位谱的详细解释。</p><h3 id=幅度谱和相位谱的定义>幅度谱和相位谱的定义</h3><h3 id=幅度谱magnitude-spectrum>幅度谱（Magnitude Spectrum）</h3><p>幅度谱描述的是图像在频率域中的强度信息，即每个频率成分的振幅大小。幅度谱是傅里叶变换结果的绝对值。</p><p>定义：<br>Magnitude(F(u,v))=∣F(u,v)∣\text{Magnitude}(F(u, v)) = |F(u, v)|Magnitude(F(u,v))=∣F(u,v)∣<br>其中 F(u,v)F(u, v)F(u,v) 是二维傅里叶变换后的频率成分。</p><h3 id=相位谱phase-spectrum>相位谱（Phase Spectrum）</h3><p>相位谱描述的是图像在频率域中的相位信息，即每个频率成分的相位角。相位谱是傅里叶变换结果的角度值。</p><p>定义：<br>Phase(F(u,v))=arg⁡(F(u,v))\text{Phase}(F(u, v)) = \arg(F(u, v))Phase(F(u,v))=arg(F(u,v))<br>其中 arg⁡(F(u,v))\arg(F(u, v))arg(F(u,v)) 是频率成分的相位角。</p><h3 id=计算过程>计算过程</h3><h3 id=二维傅里叶变换-1>二维傅里叶变换</h3><p>对图像 f(x,y)f(x, y)f(x,y) 进行二维傅里叶变换，得到频率域表示 F(u,v)F(u, v)F(u,v)：</p><p>F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(uxM+vyN)F(u, v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) \cdot e^{-j2\pi\left(\frac{ux}{M} + \frac{vy}{N}\right)}F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(Mux+Nvy)</p><p>傅里叶变换的结果 F(u,v)F(u, v)F(u,v) 是复数，可以表示为：</p><p>F(u,v)=∣F(u,v)∣ejarg⁡(F(u,v))F(u, v) = |F(u, v)| e^{j \arg(F(u, v))}F(u,v)=∣F(u,v)∣ejarg(F(u,v))</p><p>其中，∣F(u,v)∣|F(u, v)|∣F(u,v)∣ 是幅度谱，arg⁡(F(u,v))\arg(F(u, v))arg(F(u,v)) 是相位谱。</p><h3 id=区别和联系>区别和联系</h3><h3 id=区别>区别</h3><ul><li><strong>幅度谱</strong>：<ul><li>描述频率成分的强度，即频率成分的振幅大小。</li><li>强度信息通常与图像的对比度和亮度相关。</li><li>在图像处理中，幅度谱主要用于图像的整体特征分析，如图像的模糊程度和边缘信息。</li></ul></li><li><strong>相位谱</strong>：<ul><li>描述频率成分的相位，即频率成分的相位角。</li><li>相位信息与图像的结构和细节相关。</li><li>在图像处理中，相位谱主要用于图像的细节和纹理分析。</li></ul></li></ul><h3 id=联系>联系</h3><ul><li><strong>共同构成频率域表示</strong>：傅里叶变换结果由幅度谱和相位谱共同构成。完全描述图像在频率域中的表示需要同时包含幅度信息和相位信息。</li><li><strong>重建图像</strong>：从频率域重建图像时，需要同时使用幅度谱和相位谱。仅使用幅度谱或相位谱中的任意一个都无法完全重建原始图像。</li></ul><h3 id=总结-1>总结</h3><p>幅度谱和相位谱是图像傅里叶变换的两个重要组成部分。幅度谱描述频率成分的强度，反映图像的对比度和亮度；相位谱描述频率成分的相位，反映图像的结构和细节。两者共同构成了图像在频率域中的完整表示，对于图像的分析和处理都非常重要。理解它们的区别和联系，可以更好地利用频域信息进行图像处理操作。</p><h1 id=图像重建>图像重建</h1><p>利用频率域谱重建图像需要同时使用幅度谱和相位谱。下面是如何通过频率域信息重建图像的详细步骤，包括数学公式和代码示例。</p><h3 id=数学公式>数学公式</h3><h3 id=傅里叶变换和逆变换>傅里叶变换和逆变换</h3><ol><li><strong>二维傅里叶变换</strong>：<br>F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(uxM+vyN)F(u, v) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) \cdot e^{-j2\pi\left(\frac{ux}{M} + \frac{vy}{N}\right)}F(u,v)=∑x=0M−1∑y=0N−1f(x,y)⋅e−j2π(Mux+Nvy)<br>其中，f(x,y)f(x, y)f(x,y) 是空间域的图像，F(u,v)F(u, v)F(u,v) 是频率域的图像。</li><li><strong>二维傅里叶逆变换</strong>：<br>f(x,y)=1MN∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(uxM+vyN)f(x, y) = \frac{1}{MN} \sum_{u=0}^{M-1} \sum_{v=0}^{N-1} F(u, v) \cdot e^{j2\pi\left(\frac{ux}{M} + \frac{vy}{N}\right)}f(x,y)=MN1∑u=0M−1∑v=0N−1F(u,v)⋅ej2π(Mux+Nvy)<br>其中，F(u,v)F(u, v)F(u,v) 是频率域的图像，f(x,y)f(x, y)f(x,y) 是重建后的空间域图像。</li></ol><h3 id=幅度谱和相位谱-2>幅度谱和相位谱</h3><ul><li><p><strong>幅度谱</strong>：∣F(u,v)∣</p><p>∣F(u,v)∣|F(u, v)|</p></li><li><p><strong>相位谱</strong>：arg(F(u,v))</p><p>arg⁡(F(u,v))\arg(F(u, v))</p></li></ul><h3 id=重建过程>重建过程</h3><p>通过频率域的幅度谱和相位谱，可以重建图像：<br>F(u,v)=∣F(u,v)∣⋅ejarg⁡(F(u,v))F(u, v) = |F(u, v)| \cdot e^{j \arg(F(u, v))}F(u,v)=∣F(u,v)∣⋅ejarg(F(u,v))<br>然后使用二维傅里叶逆变换将其转换回空间域。</p><h3 id=示例代码>示例代码</h3><p>以下是如何使用Python和<code>numpy</code>库进行傅里叶变换、提取幅度谱和相位谱，并重建图像的代码示例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>matplotlib.pyplot</span> <span class=k>as</span> <span class=nn>plt</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scipy.fft</span> <span class=kn>import</span> <span class=n>fft2</span><span class=p>,</span> <span class=n>ifft2</span><span class=p>,</span> <span class=n>fftshift</span><span class=p>,</span> <span class=n>ifftshift</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建一个带有水平梯度的示例图像</span>
</span></span><span class=line><span class=cl><span class=n>image_size</span> <span class=o>=</span> <span class=mi>256</span>
</span></span><span class=line><span class=cl><span class=n>image</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>image_size</span><span class=p>),</span> <span class=p>(</span><span class=n>image_size</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 进行二维傅里叶变换</span>
</span></span><span class=line><span class=cl><span class=n>f_transform</span> <span class=o>=</span> <span class=n>fft2</span><span class=p>(</span><span class=n>image</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>f_transform_shifted</span> <span class=o>=</span> <span class=n>fftshift</span><span class=p>(</span><span class=n>f_transform</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 计算幅度谱和相位谱</span>
</span></span><span class=line><span class=cl><span class=n>magnitude_spectrum</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>f_transform_shifted</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>phase_spectrum</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>angle</span><span class=p>(</span><span class=n>f_transform_shifted</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 利用幅度谱和相位谱重建图像</span>
</span></span><span class=line><span class=cl><span class=n>reconstructed_f_transform</span> <span class=o>=</span> <span class=n>magnitude_spectrum</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>exp</span><span class=p>(</span><span class=mi>1</span><span class=n>j</span> <span class=o>*</span> <span class=n>phase_spectrum</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>reconstructed_f_transform_shifted</span> <span class=o>=</span> <span class=n>ifftshift</span><span class=p>(</span><span class=n>reconstructed_f_transform</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>reconstructed_image</span> <span class=o>=</span> <span class=n>ifft2</span><span class=p>(</span><span class=n>reconstructed_f_transform_shifted</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>reconstructed_image</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>reconstructed_image</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示原始图像、幅度谱、相位谱和重建图像</span>
</span></span><span class=line><span class=cl><span class=n>fig</span><span class=p>,</span> <span class=n>ax</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>24</span><span class=p>,</span> <span class=mi>6</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示原始图像</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>cmap</span><span class=o>=</span><span class=s1>&#39;gray&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;原始图像&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=s1>&#39;off&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示幅度谱</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>magnitude_spectrum</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span> <span class=n>cmap</span><span class=o>=</span><span class=s1>&#39;gray&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;幅度谱&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=s1>&#39;off&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示相位谱</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>phase_spectrum</span><span class=p>,</span> <span class=n>cmap</span><span class=o>=</span><span class=s1>&#39;gray&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;相位谱&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=s1>&#39;off&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示重建图像</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>reconstructed_image</span><span class=p>,</span> <span class=n>cmap</span><span class=o>=</span><span class=s1>&#39;gray&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;重建图像&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=o>.</span><span class=n>axis</span><span class=p>(</span><span class=s1>&#39;off&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 保存并显示图像</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>tight_layout</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>savefig</span><span class=p>(</span><span class=s2>&#34;/mnt/data/reconstructed_image.png&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</span></span></code></pre></div><h3 id=解释>解释</h3><ol><li><strong>原始图像</strong>：创建了一个带有水平梯度的示例图像。</li><li><strong>傅里叶变换</strong>：对图像进行二维傅里叶变换，得到频率域的表示。</li><li><strong>幅度谱和相位谱</strong>：提取频率域的幅度谱和相位谱。</li><li><strong>重建图像</strong>：利用幅度谱和相位谱重建频率域表示，然后通过二维傅里叶逆变换重建回空间域图像。</li></ol><h3 id=结果图像>结果图像</h3><ul><li><strong>原始图像</strong>：展示了带有水平梯度的示例图像。</li><li><strong>幅度谱</strong>：展示了频率成分的强度。</li><li><strong>相位谱</strong>：展示了频率成分的相位信息。</li><li><strong>重建图像</strong>：展示了利用频率域信息重建的图像。</li></ul><h3 id=关键点>关键点</h3><ul><li><strong>幅度谱和相位谱</strong>：幅度谱包含了图像中的频率成分的强度信息，而相位谱包含了这些频率成分的位置信息。</li><li><strong>重建图像</strong>：同时使用幅度谱和相位谱信息可以完整地重建原始图像。如果只使用其中一个，重建的图像会丢失一些信息。</li></ul><h3 id=总结-2>总结</h3><p>通过傅里叶变换将图像转换到频率域，可以提取幅度谱和相位谱。利用这两个谱，我们可以通过傅里叶逆变换将频率域信息转换回空间域，重建出原始图像。理解和使用幅度谱和相位谱在图像处理和分析中具有重要的应用。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2024-12-02</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://fjyu95.github.io/posts/opencv-9d600a59535d4431919d0b76e8b198bf/ data-title=OpenCV data-hashtags=OpenCV,python><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://fjyu95.github.io/posts/opencv-9d600a59535d4431919d0b76e8b198bf/ data-hashtag=OpenCV><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://fjyu95.github.io/posts/opencv-9d600a59535d4431919d0b76e8b198bf/ data-title=OpenCV><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://fjyu95.github.io/posts/opencv-9d600a59535d4431919d0b76e8b198bf/ data-title=OpenCV><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://fjyu95.github.io/posts/opencv-9d600a59535d4431919d0b76e8b198bf/ data-title=OpenCV><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/opencv/>OpenCV</a>,&nbsp;<a href=/tags/python/>Python</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/online-toolkits-b6041ebb846649659d2145465714616c/ class=prev rel=prev title=在线实用工具><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>在线实用工具</a>
<a href=/posts/hardware-5e47a1c2d08944afae871a05bef9d9bf/ class=next rel=next title=硬件杂谈>硬件杂谈<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.145.0">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.3.0"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2020 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://fjyu95.github.io/ target=_blank>fjyu95</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>